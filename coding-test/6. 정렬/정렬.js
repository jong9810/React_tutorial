// 정렬 : 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
// 정렬 알고리즘은 이진 탐색(Binary Search)의 전처리 과정이기도 하다.
// 정렬의 종류 : 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬
// 일반적으로 문제에서 요구하는 조건에 따라 적절한 정렬 알고리즘이 공식처럼 사용된다.

// reverse() 메서드 : 배열의 순서를 뒤집는 메서드(O(N)의 시간 복잡도)

// 선택 정렬
// 선택 정렬 과정
// 1) 데이터가 무작위로 여러 개 있을 때, 이 중 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾼다.
// 2) 정렬되지 않은 데이터 중 가장 작은 데이터를 선택해 정렬되지 않은 데이터의 맨 앞에 있는 데이터와 바꾼다.
// 3) 2)번 과정을 데이터의 개수만큼 반복한다.
// 선택 정렬의 시간 복잡도는 빅오 표기법으로 O(N2)으로 표현할 수 있다(2중 반복문).

// 삽입 정렬
// 삽입 정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적이다.
// 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.
// 오름차순으로 정렬하는 경우, 삽입 정렬에서 정렬이 이루어진 원소들은 항상 오름차순을 유지하고 있다.
// 따라서 특정한 데이터가 삽입될 위치를 선정할 때, 삽입될 데이터보다 작은 데이터를 만나면 그 오른쪽에 데이터를 삽입하면 된다.
// 삽입 정렬의 시간 복잡도는 O(N2)인데, 삽입정렬의 특징은 정렬이 거의 된 리스트인 경우 퀵 정렬 알고리즘보다 강력하다.

// 퀵 정렬
// 선택, 삽입, 퀵 정렬 중 퀵 정렬이 가장 많이 사용된다.
// 퀵 정렬과 비교할 만큼 빠른 알고리즘으로 '병합 정렬'알고리즘이 있다.
// 퀵 정렬은 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이다.
// 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
// 퀵 정렬에서는 피벗(Pivot)이 사용된다. 피벗이란 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'이다.
// 피벗을 설정하고 리스트를 분할하는 방법에 따라 여러 가지 방식으로 퀵 정렬을 구분하는데,
// 가장 대표적인 분할 방식은 리스트의 첫 번째 데이터를 피벗으로 정하는 '호어 분할(Hoare Partition) 방식'이 있다.
