// - 프레임 : 물리 메모리를 일정한 크기로 나눈 블록
// - 페이지 : 가상 메모리를 일정한 크기로 나눈 블록
// - 가상 메모리 기법
// 주기억장치보다 더 큰 용량의 프로그램을 실행하기 위해 프로그램의 일부만 주기억장치에 적재하여 사용하는 기법이다. ex) 운영체제
// - 시간 지역성(temporal locality) : 특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은 것을 말한다.
// - 공간 지역성(spatial locality) :  특성 클러스터의 기억 장소들에 대해 참조가 집중적으로 이루어지는 경향으로, 참조된 메모리 근처의 메모리를 참조합니다.

// - 페이지 교체 알고리즘
// 필요한 페이지가 메모리에 없을 때 page-fault가 발생하고 Backing Store에서 해당 페이지를 찾아 빈 프레임에 로딩해야 하는데,
// 이때 빈 프레임이 없을 경우 희생 당할 프레임(victim frame)을 고르는 알고리즘이다.

// - 페이지 교체 알고리즘 종류
// 1) OPT(Optimal) : 앞으로 가장 오래 사용되지 않을 페이지를 교체
// 가장 이상적이다.
// 프로세스가 앞으로 사용할 페이지를 미리 알아야 함(거의 불가능).
// 비교 연구 목적을 위해 주로 사용된다.
// 2) FIFO(First In First Out) : 가장 먼저 들어온 페이지를 교체
// 메모리에 가장 먼저 들어온 페이지를 먼저 내보낸다.
// 간단하고 초기화 코드에 대해 적절한 방법이다.
// 들어온 시간을 저장하거나 올라온 순서를 큐에 저장한다.
// 3) LRU(Least Recently Used0) : 가장 오랫동안 사용하지 않은 페이지를 교체
// 가정 : 가장 오랫동안 사용하지 않았던 데이터라면 앞으로도 사용할 확률이 적을 것이다.
// 시간 지역성(temporal locality) 성질을 고려한다(최근에 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질).
// 사용된 시간을 알 수 있는 부분을 저장하여 가장 오랫동안 참조되지 않는 데이터를 제거한다(페이지마다 카운터 필요).
// 큐로 구현이 가능하다. 사용한 데이터를 큐에서 제거하여 맨 위로 다시 올리고, 프레임이 모자랄 경우 맨 아래에 있는 데이터를 삭제하는 방식으로 구현한다.
// 단점 : 프로세스가 주기억장치에 접근할 때마다 참조된 페이지 시간을 기록해야 하므로 막대한 오버헤드가 발생하고,
//        카운터 큐, 스택과 같은 별도의 하드웨어가 필요하다.
// 4) LFU(Least Frequently Used) : 참조 횟수가 가장 낮은 페이지를 교체
// 페이지의 참조 횟수로 교체할 페이지를 결정하는 방식이다.
// LRU는 직전 참조된 시점만을 반영하지만, LFU는 참조 횟수를 통해 장기적 시간 규모에서의 참조 성향을 고려할 수 있다.
// 단점 : 가장 최근에 불러운 페이지가 교체될 가능성이 높다. 구현이 복잡하고, 막대한 오버헤드가 발생할 수 있다.
// 5) MFU(Most Frequently Used) : 참조 횟수가 가장 많으 페이지를 교체
// 가정 : 가장 많이 사용된 페이지가 앞으로는 덜 사용될 것이다.
// 6) NUR(Not Used Recently || Not Recently Used) : 최근에 사용하지 않은 페이지를 교체(LRU와 유사한 알고리즘)
// 클럭 알고리즘이라고도 한다.
// 교체되는 페이지의 참조 시점이 가장 오래되었다는 것을 보장하지는 못한다.
// LRU에 비해 적은 오버헤드가 발생하고 적절한 성능을 가진다.
// 동일 그룸 내에서 페이지를 무작위로 선택한다.
// 각 페이지마다 두 개의 비트가 사용된다(참조 비트(Reference Bit), 변형 비트(Modified Bit || Birty Bit)).
// - 참조 비트 : 페이지가 참조되지 않았을 때는 0, 호출되었을 때는 1(모든 참조비트는 주기적으로 0으로 변경됨).
// - 변형 비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1.
// 우선순위는 참조 비트가 변형 비트보다 크다.
