// 2022년 04월 정보처리기사 필기
//-------------------------------------------------------------------------------------------------------------------------------------------------

// 소프트웨어 설계

// 1. UML 다이어그램 중 순차 다이어그램
// (1) 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링하는 것이다.
// (X) 주로 시스템의 정적(->동적) 측면을 모델링하기 위해 사용한다.
// (3) 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다.
// (4) 회귀 메시지(Self-message), 제어 블록(Statement-block) 등으로 구성된다.
// <해설>
// - 순차 다이어그램은 행위 다이어그램이므로 동적이고, 순차적인 표현을 위한 다이어그램이다.

// 2. 메시지 지향 미들웨어(Message-Oriented Middleware, MOM)
// (X) 느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.
// (2) 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다.
// (3) 송신측과 수싲측의 연결 시 메시지 큐를 활용하는 방법이 있다.
// (4) 상이한 애프리케이션 간 통신을 비동기 방식으로 지원한다.
// <해설>
// MOM 설명
// - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.
// - 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다.
// - MOM은 즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용한다.
// <용어 정리>
// - 미들웨어
// : 공통 서비스 및 기능을 애플리케이션에 제공하여 개발자와 운영자가 애플리케이션을 더욱 효율적으로 구축하고 배포하도록 돕는 소프트웨어 및 클라우드 서비스이다.
// - 이기종 컴퓨팅 : 하나 이상의 프로세서 또는 코어를 사용하는 시스템.

// 3. 익스트림 프로그래밍
// (X) 대표적인 구조적 방법론 중 하나이다.
// (2) 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.
// (3) 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어올리는 것이다.
// (4) 구체적인 실천 방법을 정의하고 있으며, 개발 문서보다는 소스코드에 중점을 둔다.
// <해설>
// - 구조적 방법론이 아니라 애자일 방법론 중 하나이다.
// <용어 정리>
// - 애자일(Agile) : 날렵한, 민첩한, 기민한이라는 뜻으로, 소프트웨어 개발 방법론 중 하나인 애자일 프로세스에서 처음 사용되었다.

// 4. 유스 케이스(Use case)의 구성요소 간의 관계에 포함되지 않는 것은?
// (1) 연관
// (2) 확장
// (X) 구체화
// (4) 일반화
// <해설>
// - 연관 관계(Association) (표기 : ㅡ)
// 유스 케이스와 액터 간의 상호작용이 있음을 표현
// - 포함 관계(Include) (표기 : --->)
// 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계
// - 확장 관계(Extend) (표기 : --->)
// 확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성되는 관계
// - 일반화 관계(Generalization) (표기 : ㅡ▷)
// 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계
// <용어 정리>
// - 유스케이스(Use case) (표기 : 동그라미 안에 내용)
// 시스템의 하나 이상의 액터 또는 이해관계자에게 관측가능한 결과를 산출하는, 시스템에 의해 수행되는 일련의 활동의 명세.
// - 액터(actor) (표기 : 졸라맨 아래 액터 이름)
// 시스템의 외부에 있고 시스템과 상호작용을 하는 사람(시스템의 기능을 사용하는 사람) 또는 시스템(시스템에 정보를 제공하는 또 다른 시스템)

// 5. 요구사항 분석에서 비기능적(Nonfunctional) 요구
// (X) 시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다.
// (2) '차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다.'는 비기능적 요구이다.
// (X) 시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다.
// (X) '금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다.'는 비기능적 요구이다.
// <해설>
// - 기능적 요구사항
// 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항
// - 비기능적 요구사항
// 시스템 구축에 대한 성능, 보안, 품질, 안정성 등으로 실제 수행에 보조적인 요구사항

// 6. 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어
// (X) Package Diagram
// (X) State Transition Diagram
// (X) Deployment Diagram
// (4) Entity-Relationship Diagram
// <해설>
// - (1), (2), (3) : UML 다이어그램
// - (4) : 정보공학 방법론

// 7. 미들웨어(Middleware)
// (1) 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다,
// (X) 미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.
// (3) 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다.
// (4) 여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러가지 형태로 연결이 가능하다.
// <해설>
// - 미들웨어 설명
// 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어이다.
// 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어이다.
// 표준화된 인터페이스를 통하여 시스템 간의 데이터 교환에 있어 일관성을 제공한다.
// 애플리케이션과 운영체제 사이에서 중간 매개 역할을 하는 다목적 소프트웨어이다.

// 8. UI(User Interface) 설계 지침
// (1) 이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다.
// (2) 주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다.
// (3) 치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.
// (4) 사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 한다.
// <해설>
// - 사용자 중심
// 사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공해야 하므로 실 사용자에 대한 이해가 바탕이 되어야 함.
// - 일관성
// 버튼이나 조작 방법을 사용자가 기억하기 빠르고 쉽게 습득할 수 있도록 설계해야 함.
// - 단순성
// 조작 방법은 가장 간단하게 작동되도록 하여 인지적 부담을 최소화해야 함.
// - 결과 예측 가능
// 작동시킬 기능만 보고도 결과 예측이 가능해야 함.
// - 가시성
// 주요 기능을 메인 화면에 노출하여 쉬운 조작이 가능해야 함.
// - 표준화
// 디자인을 표준화하여 기능 구조의 선행 학습 이후 쉽게 사용 가능해야 함.
// - 접근성
// 사용자의 직무, 연령, 성별 등이 고려된 다양한 계층을 수용해야 함.
// - 명확성
// 사용자가 개념적으로 쉽게 인지해야 함.
// - 오류 발생 해결
// 사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야 함.

// 9. 객체 지향 개념에서 다형성(Polymorphism)
// (1) 다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.
// (2) 다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.
// (3) 메소드 오버라이딩(Overriding)은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다.
// (X) 메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다.
// <해설>
// - 오버로딩
// 같은 이름의 메소드를 중복하여 정의하는 것
// 한 클래스 내에서 메서드의 이름은 동일하지만 매개변수의 수나 타입을 다르게 하여 재정의하는 것
// - 오버라이딩
// 상속 관계에서만 발생하고, 슈퍼 클래스의 메서드를 서브 클래스에서도 동일한 메소드명으로 재정의하는 것

// 10. 소프트웨어 개발 영역을 결정하는 요소 중 다음 사항과 관계있는 것은?
// - 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
// - 기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어
// - 순서적 연산에 의해 소프트웨어를 실행하는 절차
// (X) 기능(Function)
// (X) 성능(Performance)
// (X) 제약조건(Constraint)
// (4) 인터페이스(Interface)
// <해설>
// - 인터페이스 : 서로 다른 두 시스템이나 소프트웨어 등을 이어주는 부분 또는 접속 장치를 의미

// 11. 객체에 대한 설명
// (1) 객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다.
// (X) 객체는 공통 속성을 공유하는 객체들의 집합이다.
// (3) 객체는 필요한 자료 구조와 이에 수반되는 함수들을 가진 하나의 독립된 존재이다.
// (4) 객체의 상태는 속성값에 의해 정의된다.
// <해설>
// - 클래스는 공통 속성을 공유하는 객체들의 집합이다.

// 12. 객체 지향 개념
// - 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것
// (X) Inheritance(상속)
// (X) Class(클래스)
// (3) Encapsulation(캡슐화)
// (X) Association(연관)
// <해설>
// - 클래스 : 하나 이상의 유사한 객체들을 묶는다.
// - 캡슐화 : 서로 관련성이 많은 데이터들과 연산들을 묶는다.

// 13. 애자일(Agile) 프로세스 모델
// (X) 변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.
// (2) 프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다.
// (3) 협상과 계약보다는 고객과의 협력을 중시한다.
// (4) 문서 중심이 아닌, 실행가능한 소프트웨어를 중시한다.
// <해설>
// - 애자일 개발 프로세스
// 개발에 대한 개념적 방법론으로, 개발 프로젝트 기간을 짧은 주기로 나눠 반복적인 개발을 하는 것이 특징이다.
// 고객 관점의 효율적이고 민첩한 변화 대응을 중시한다.
// - 애자일 선언문
// "프로세스, 도구보다는 (사람과 상호작용)을
// 광범위한 문서보다는 (실제 작동하는 제품)을
// 계약, 협상보다는 (고객 협력)을
// 계획을 따르기보다는 (변화 대응)을"

// 14. 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며,
//     인터페이스를 통해서만 접근할 수 있는 것은?
// (X) Model
// (X) Sheet
// (3) Component
// (X) Cell
// <해설>
// - 컴포넌트
// 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈
// 특정 기능수행을 위해 독립적으로 분리

// 15. GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?
// (1) Adaptor 패턴
// (2) Bridge 패턴
// (X) Builder 패턴
// (4) Proxy 패턴
// <해설>
// - 생성 패턴 : 객체를 생성하는 것에 대한 패턴
// 1) 추상 팩토리 패턴(abstract factory)
// 2) 빌더 패턴(builder)
// 3) 팩토리 메소드 패턴(factory method)
// 4) 프로토타입 패턴(prototype)
// 5) 싱글톤 패턴(singleton)
// - 구조 패턴 : 구조를 통해 확장성을 꾀하는 패턴
// 1) 어댑터 패턴(adapter)
// 2) 브릿지 패턴(bridge)
// 3) 컴포지트 패턴(composite)
// 4) 데코레이터 패턴(decorator)
// 5) 퍼사드 패턴(facade)
// 6) 플라이웨잇 패턴(flyweight)
// 7) 프록시 패턴(proxy)
// - 행동 패턴 : 행위의 변경, 수정 등을 위한 패턴
// 1) 역할 사슬 패턴(책임 연쇄, chain of responsibility)
// 2) 커맨드 패턴(command)
// 3) 인터프리터 패턴(interpreter)
// 4) 이터레이터 패턴(반복자, iterator)
// 5) 미디에이터 패턴(중재자, mediator)
// 6) 메멘토 패턴(memento)
// 7) 옵저버 패턴(observer)
// 8) 상태 패턴(state)
// 9) 전략 패턴(strategy)
// 10) 템플릿 메소드 패턴(template method)
// 11) 비지터 패턴(방문자, visitor)
// <용어 정리>
// - GoF : 소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴
// - 디자인 패턴
// 모듈의 세분화된 역할이나 모듈들 간의 인터페이스 구현 방식을 설계할 때 참조할 수 있는 전형적인 해결방식을 말한다.
// 디자인 패턴을 통해 설계 문제, 해결방법, 해결방법을 언제 적용해야 할지, 그 결과는 무엇인지 등을 알 수 있다.
// 디자인 패턴은 한 패턴에서 변형을 가하거나 어떠한 요구사항을 반영하면 다른 패턴으로 변형되는 특징이 있다.

// 16. UI와 관련된 기본 개념
// - 시스템의 상태와 사용자의 지시ㅔ 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해설할 수 있도록 도와주는 것은?
// (1) Feedback
// (X) Posture(자세)
// (X) Module
// (X) Hash
// <해설>
// - 피드백 : 처리된 결과를 측정하고 목표에 도달되었는지를 검사하며 불충분한 경우 다시 입력하는 요소

// 17. UI의 종류로 멀티 터치(Multi-touch), 동작 인식(Gesture Recognition) 등 사용자의 자연스러운 움직임을 인식하여
// 서로 주고받는 정보를 제공하는 사용자 인터페이스를 의미하는 것은?
// (X) GUI(Graphical User Interface)
// (X) OUI(Organic User Interface)
// (3) NUI(Natural User Interface)
// (X) CLI(Command Line Interface)
// <해설>
// - 사용자 인터페이스(UI)의 구분
// 1) CLI : 텍스트 형태 인터페이스
// 2) GUI : 마우스로 선택하여 작업하는 그래픽 환경 인터페이스
// 3) NUI : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
// 4) VUI : 사람의 음성으로 기기를 조작하는 인터페이스
// 5) OUI : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

// 18. 소프트웨어 모델링
// (X) 모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다.
// (2) 구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구사항의 결과를 표현한다.
// (3) 객체 지향 방법론에서는 UML 표기법을 사용한다.
// (4) 소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다.
// <해설>
// - (1) 반례 : 유스케이스 명세로부터 필요한 요소들을 가져와 도메인 모델로 정리할 수 있음.
// <용어 정리>
// - DFD(데이터 흐름도) : 프로세스나 시스템의 정보 흐름을 나타내는 도표.
// - DD(데이터 사전) : 프로그래머의 편의를 위해 데이터 모델 내의 데이터 객체들이나 항목들의 설명을 모아놓은 것.
// - UML 표기법 : 시스템을 모델로 표현해주는 대표적인 모델링 언어.

// 19. 유스 케이스 다이어그램
// (X) 시스템과 상호작용하는 외부 시스템은 액터로 파악해서는 안된다.
// (2) 유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.
// (3) 시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.
// (4) 액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.
// <해설>
// - 액터 : 시스템과 상호작용하는 모든 것(사람, 기계, 시스템 등)
// <용어 정리>
// - 유스케이스
// 행위자(actor)가 관심을 가지고 있는 유용한 일을 달성하기 위한 시나리오의 집합을 명시한다.
// 사용자 입장에서 바라본 시스템의 특성을 설명한 구조로서, 행위자, 시간의 흐름, 또는 시스템에 의해 개시되는 시나리오 집합의 형태를 갖추고 있다.

// 20. 소프트웨어 아키텍처 모델 MVC(Model-View-Controller)
// (1) MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.
// (X) 모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브 시스템이 각각 하나씩 연결된다.
// (3) 뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.
// (4) 제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.
// <해설>
// - 한 개의 모델에 대해 여러 개의 뷰를 만들 수도 있다.
// - 모델은 서브 시스템의 핵심 기능과 데이터를 보관하며 MVC 패턴에서는 여러 개의 뷰를 만들 수 있으므로
// 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 어플리케이션에 적합하다.
// <용어 정리>
// - MVC : 사용자 인터페이스, 데이터 및 논리 제어를 구현하는 데 널리 사용되는 소프트웨어 디자인 패턴

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 소프트웨어 개발

// 21. 통합 테스트(Integration Test)
// (1) 시스템을 구성하는 모듈의 인터페이스와 결함을 테스트하는 것이다.
// (2) 하향식 통합 테스트의 경우, 넓이 우선(Breath-First) 방식으로 테스트를 할 모듈을 선택할 수 있다.
// (X) 상향식 통합 테스트의 경우, 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.
// (4) 모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘 되고 있는지를 빨리 파악하고자할 때 상향식보다는 하향식 통합 테스트를 사용하는 것이 좋다.
// <해설>
// - 상향식 통합 테스트(Bottom-Up Integration Test)
// 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합
// 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster) 필요
// - 하향식 통합 테스트(Top-Down Integration Test)
// 상위 모듈에서 하위 모듈 방향으로 통합
// 깊이 우선 통합법, 넓이 우선 통합법 사용
// 초기부터 사용자에게 시스템 구조를 보여줌

// 22. 이진 탐색 방법
// - 이진 탐색 동작 방식
// 1) 배열의 중간 값을 찾음.
// 2) 중간 값과 검색 값을 비교
// 2-1) 중간 값이 검색 값과 같으면 끝
// 2-2) 중간 값이 검색 값보다 작으면 오른쪽 구간을 탐색
// 2-3) 중간 값이 검색 값보다 크면 왼쪽 구간을 탐색
// 3) 값을 찾거나 간격이 비었을 때까지 반복

// 23. 소프트웨어 공학에서 워크스루(Walk-through)
// (1) 사용 사례를 확장하여 명세하거나 설계 다이어그램, 원시 코드, 테스트 케이스 등에 적용할 수 있다.
// (2) 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.
// (X) 인스펙션(Inspection)과 동일한 의미를 가진다.
// (4) 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해보는 것이다.
// <해설>
// - 워크스루(Walk-through) : 요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견.
// - 인스펙션(Inspection) : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견.

// 24. 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?
// (X) 복호화
// (2) 형상관리
// (X) 저작권
// (X) 크랙
// <해설>
// - 복호화 : 디코딩, 즉 부호화된 데이터를 부호화되기 전 형태로 바꾸어 사람이 읽을 수 있는 형태로 되돌려 놓은 것
// - 형상관리 : 소프트웨어의 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동
// - 저작권 : 창작물을 만든 이가 자기 저작물에 대해 가지는 법적 권리
// - 크랙 : 소프트웨어를 수정하여 개발자가 원하지 않는 기능들, 보통은 수정 방식(복사 보호, 소프트웨어 조작 보호)을 비활성화하거나 제거하는 일

// 25. 테스트 케이스
// (1)

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 데이터베이스 구축

// 41.

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 프로그래밍 언어 활용

// 61.

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 정보시스템 구축관리

// 81.

//-------------------------------------------------------------------------------------------------------------------------------------------------
