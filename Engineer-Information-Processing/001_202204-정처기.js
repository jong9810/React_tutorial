// 2022년 04월 정보처리기사 필기
//-------------------------------------------------------------------------------------------------------------------------------------------------

// 소프트웨어 설계

// 1. UML 다이어그램 중 순차 다이어그램
// (1) 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링하는 것이다.
// (X) 주로 시스템의 정적(->동적) 측면을 모델링하기 위해 사용한다.
// (3) 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다.
// (4) 회귀 메시지(Self-message), 제어 블록(Statement-block) 등으로 구성된다.
// <해설>
// - 순차 다이어그램은 행위 다이어그램이므로 동적이고, 순차적인 표현을 위한 다이어그램이다.

// 2. 메시지 지향 미들웨어(Message-Oriented Middleware, MOM)
// (X) 느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.
// (2) 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다.
// (3) 송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다.
// (4) 상이한 애프리케이션 간 통신을 비동기 방식으로 지원한다.
// <해설>
// MOM 설명
// - 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.
// - 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용한다.
// - MOM은 즉각적인 응답을 원하는 경우가 아니라 다소 느리고 안정적인 응답을 필요로 하는 경우에 많이 사용한다.
// <용어 정리>
// - 미들웨어
// : 공통 서비스 및 기능을 애플리케이션에 제공하여 개발자와 운영자가 애플리케이션을 더욱 효율적으로 구축하고 배포하도록 돕는 소프트웨어 및 클라우드 서비스이다.
// - 이기종 컴퓨팅 : 하나 이상의 프로세서 또는 코어를 사용하는 시스템.

// 3. 익스트림 프로그래밍
// (X) 대표적인 구조적 방법론 중 하나이다.
// (2) 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.
// (3) 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어올리는 것이다.
// (4) 구체적인 실천 방법을 정의하고 있으며, 개발 문서보다는 소스코드에 중점을 둔다.
// <해설>
// - 구조적 방법론이 아니라 애자일 방법론 중 하나이다.
// <용어 정리>
// - 애자일(Agile) : 날렵한, 민첩한, 기민한이라는 뜻으로, 소프트웨어 개발 방법론 중 하나인 애자일 프로세스에서 처음 사용되었다.

// 4. 유스 케이스(Use case)의 구성요소 간의 관계에 포함되지 않는 것은?
// (1) 연관
// (2) 확장
// (X) 구체화
// (4) 일반화
// <해설>
// - 연관 관계(Association) (표기 : ㅡ)
// 유스 케이스와 액터 간의 상호작용이 있음을 표현
// - 포함 관계(Include) (표기 : --->)
// 하나의 유스케이스가 다른 유스케이스의 실행을 전제로 할 때 형성되는 관계
// - 확장 관계(Extend) (표기 : --->)
// 확장 기능 유스케이스와 확장 대상 유스케이스 사이에 형성되는 관계
// - 일반화 관계(Generalization) (표기 : ㅡ▷)
// 유사한 유스케이스 또는 액터를 모아 추상화한 유스케이스 또는 액터와 연결시켜 그룹을 만들어 이해도를 높이기 위한 관계
// <용어 정리>
// - 유스케이스(Use case) (표기 : 동그라미 안에 내용)
// 시스템의 하나 이상의 액터 또는 이해관계자에게 관측가능한 결과를 산출하는, 시스템에 의해 수행되는 일련의 활동의 명세.
// - 액터(actor) (표기 : 졸라맨 아래 액터 이름)
// 시스템의 외부에 있고 시스템과 상호작용을 하는 사람(시스템의 기능을 사용하는 사람) 또는 시스템(시스템에 정보를 제공하는 또 다른 시스템)

// 5. 요구사항 분석에서 비기능적(Nonfunctional) 요구
// (X) 시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다.
// (2) '차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다.'는 비기능적 요구이다.
// (X) 시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다.
// (X) '금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다.'는 비기능적 요구이다.
// <해설>
// - 기능적 요구사항
// 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항
// - 비기능적 요구사항
// 시스템 구축에 대한 성능, 보안, 품질, 안정성 등으로 실제 수행에 보조적인 요구사항

// 6. 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어
// (X) Package Diagram
// (X) State Transition Diagram
// (X) Deployment Diagram
// (4) Entity-Relationship Diagram
// <해설>
// - (1), (2), (3) : UML 다이어그램
// - (4) : 정보공학 방법론

// 7. 미들웨어(Middleware)
// (1) 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다,
// (X) 미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.
// (3) 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다.
// (4) 여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러가지 형태로 연결이 가능하다.
// <해설>
// - 미들웨어 설명
// 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어이다.
// 이기종 하드웨어, 소프트웨어, 네트워크, 프로토콜, PC환경, 운영체제 환경 등에서 시스템 간의 표준화된 연결을 도와주는 소프트웨어이다.
// 표준화된 인터페이스를 통하여 시스템 간의 데이터 교환에 있어 일관성을 제공한다.
// 애플리케이션과 운영체제 사이에서 중간 매개 역할을 하는 다목적 소프트웨어이다.

// 8. UI(User Interface) 설계 지침
// (1) 이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다.
// (2) 주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다.
// (X) 치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.
// (4) 사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 한다.
// <해설>
// - 사용자 중심
// 사용자가 이해하기 쉽고 편하게 사용할 수 있는 환경을 제공해야 하므로 실 사용자에 대한 이해가 바탕이 되어야 함.
// - 일관성
// 버튼이나 조작 방법을 사용자가 기억하기 빠르고 쉽게 습득할 수 있도록 설계해야 함.
// - 단순성
// 조작 방법은 가장 간단하게 작동되도록 하여 인지적 부담을 최소화해야 함.
// - 결과 예측 가능
// 작동시킬 기능만 보고도 결과 예측이 가능해야 함.
// - 가시성
// 주요 기능을 메인 화면에 노출하여 쉬운 조작이 가능해야 함.
// - 표준화
// 디자인을 표준화하여 기능 구조의 선행 학습 이후 쉽게 사용 가능해야 함.
// - 접근성
// 사용자의 직무, 연령, 성별 등이 고려된 다양한 계층을 수용해야 함.
// - 명확성
// 사용자가 개념적으로 쉽게 인지해야 함.
// - 오류 발생 해결
// 사용자가 오류에 대한 상황을 정확하게 인지할 수 있어야 함.

// 9. 객체지향 개념에서 다형성(Polymorphism)
// (1) 다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.
// (2) 다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.
// (3) 메소드 오버라이딩(Overriding)은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다.
// (X) 메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다.
// <해설>
// - 오버로딩
// 같은 이름의 메소드를 중복하여 정의하는 것
// 한 클래스 내에서 메서드의 이름은 동일하지만 매개변수의 수나 타입을 다르게 하여 재정의하는 것
// - 오버라이딩
// 상속 관계에서만 발생하고, 슈퍼 클래스의 메서드를 서브 클래스에서도 동일한 메소드명으로 재정의하는 것

// 10. 소프트웨어 개발 영역을 결정하는 요소 중 다음 사항과 관계있는 것은?
// - 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
// - 기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어
// - 순서적 연산에 의해 소프트웨어를 실행하는 절차
// (X) 기능(Function)
// (X) 성능(Performance)
// (X) 제약조건(Constraint)
// (4) 인터페이스(Interface)
// <해설>
// - 인터페이스 : 서로 다른 두 시스템이나 소프트웨어 등을 이어주는 부분 또는 접속 장치를 의미

// 11. 객체에 대한 설명
// (1) 객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다.
// (X) 객체는 공통 속성을 공유하는 클래스들의 집합이다.
// (3) 객체는 필요한 자료 구조와 이에 수반되는 함수들을 가진 하나의 독립된 존재이다.
// (4) 객체의 상태는 속성값에 의해 정의된다.
// <해설>
// - 클래스는 공통 속성을 공유하는 객체들의 집합이다.

// 12. 객체지향 개념
// - 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것
// (X) Inheritance(상속)
// (X) Class(클래스)
// (3) Encapsulation(캡슐화)
// (X) Association(연관)
// <해설>
// - 클래스 : 하나 이상의 유사한 객체들을 묶는다.
// - 캡슐화 : 서로 관련성이 많은 데이터들과 연산들을 묶는다.

// 13. 애자일(Agile) 프로세스 모델
// (X) 변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.
// (2) 프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다.
// (3) 협상과 계약보다는 고객과의 협력을 중시한다.
// (4) 문서 중심이 아닌, 실행가능한 소프트웨어를 중시한다.
// <해설>
// - 애자일 개발 프로세스
// 개발에 대한 개념적 방법론으로, 개발 프로젝트 기간을 짧은 주기로 나눠 반복적인 개발을 하는 것이 특징이다.
// 고객 관점의 효율적이고 민첩한 변화 대응을 중시한다.
// - 애자일 선언문
// "프로세스, 도구보다는 (사람과 상호작용)을
// 광범위한 문서보다는 (실제 작동하는 제품)을
// 계약, 협상보다는 (고객 협력)을
// 계획을 따르기보다는 (변화 대응)을"

// 14. 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며,
//     인터페이스를 통해서만 접근할 수 있는 것은?
// (X) Model
// (X) Sheet
// (3) Component
// (X) Cell
// <해설>
// - 컴포넌트
// 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈
// 특정 기능수행을 위해 독립적으로 분리

// 15. GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?
// (1) Adaptor 패턴
// (2) Bridge 패턴
// (X) Builder 패턴
// (4) Proxy 패턴
// <해설>
// - 생성 패턴 : 객체를 생성하는 것에 대한 패턴
// 1) 추상 팩토리 패턴(abstract factory)
// 2) 빌더 패턴(builder)
// 3) 팩토리 메소드 패턴(factory method)
// 4) 프로토타입 패턴(prototype)
// 5) 싱글톤 패턴(singleton)
// - 구조 패턴 : 구조를 통해 확장성을 꾀하는 패턴
// 1) 어댑터 패턴(adapter)
// 2) 브릿지 패턴(bridge)
// 3) 컴포지트 패턴(composite)
// 4) 데코레이터 패턴(decorator)
// 5) 퍼사드 패턴(facade)
// 6) 플라이웨잇 패턴(flyweight)
// 7) 프록시 패턴(proxy)
// - 행동 패턴 : 행위의 변경, 수정 등을 위한 패턴
// 1) 역할 사슬 패턴(책임 연쇄, chain of responsibility)
// 2) 커맨드 패턴(command)
// 3) 인터프리터 패턴(interpreter)
// 4) 이터레이터 패턴(반복자, iterator)
// 5) 미디에이터 패턴(중재자, mediator)
// 6) 메멘토 패턴(memento)
// 7) 옵저버 패턴(observer)
// 8) 상태 패턴(state)
// 9) 전략 패턴(strategy)
// 10) 템플릿 메소드 패턴(template method)
// 11) 비지터 패턴(방문자, visitor)
// <용어 정리>
// - GoF : 소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴
// - 디자인 패턴
// 모듈의 세분화된 역할이나 모듈들 간의 인터페이스 구현 방식을 설계할 때 참조할 수 있는 전형적인 해결방식을 말한다.
// 디자인 패턴을 통해 설계 문제, 해결방법, 해결방법을 언제 적용해야 할지, 그 결과는 무엇인지 등을 알 수 있다.
// 디자인 패턴은 한 패턴에서 변형을 가하거나 어떠한 요구사항을 반영하면 다른 패턴으로 변형되는 특징이 있다.

// 16. UI와 관련된 기본 개념
// - 시스템의 상태와 사용자의 지시ㅔ 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해설할 수 있도록 도와주는 것은?
// (1) Feedback
// (X) Posture(자세)
// (X) Module
// (X) Hash
// <해설>
// - 피드백 : 처리된 결과를 측정하고 목표에 도달되었는지를 검사하며 불충분한 경우 다시 입력하는 요소

// 17. UI의 종류로 멀티 터치(Multi-touch), 동작 인식(Gesture Recognition) 등 사용자의 자연스러운 움직임을 인식하여
// 서로 주고받는 정보를 제공하는 사용자 인터페이스를 의미하는 것은?
// (X) GUI(Graphical User Interface)
// (X) OUI(Organic User Interface)
// (3) NUI(Natural User Interface)
// (X) CLI(Command Line Interface)
// <해설>
// - 사용자 인터페이스(UI)의 구분
// 1) CLI : 텍스트 형태 인터페이스
// 2) GUI : 마우스로 선택하여 작업하는 그래픽 환경 인터페이스
// 3) NUI : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
// 4) VUI : 사람의 음성으로 기기를 조작하는 인터페이스
// 5) OUI : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

// 18. 소프트웨어 모델링
// (X) 모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다.
// (2) 구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구사항의 결과를 표현한다.
// (3) 객체지향 방법론에서는 UML 표기법을 사용한다.
// (4) 소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다.
// <해설>
// - (1)의 반례 : 유스케이스 명세로부터 필요한 요소들을 가져와 도메인 모델로 정리할 수 있음.
// <용어 정리>
// - DFD(데이터 흐름도) : 프로세스나 시스템의 정보 흐름을 나타내는 도표.
// - DD(데이터 사전) : 프로그래머의 편의를 위해 데이터 모델 내의 데이터 객체들이나 항목들의 설명을 모아놓은 것.
// - UML 표기법 : 시스템을 모델로 표현해주는 대표적인 모델링 언어.

// 19. 유스 케이스 다이어그램
// (X) 시스템과 상호작용하는 외부 시스템은 액터로 파악해서는 안된다.
// (2) 유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.
// (3) 시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.
// (4) 액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.
// <해설>
// - 액터 : 시스템과 상호작용하는 모든 것(사람, 기계, 시스템 등)
// <용어 정리>
// - 유스케이스
// 행위자(actor)가 관심을 가지고 있는 유용한 일을 달성하기 위한 시나리오의 집합을 명시한다.
// 사용자 입장에서 바라본 시스템의 특성을 설명한 구조로서, 행위자, 시간의 흐름, 또는 시스템에 의해 개시되는 시나리오 집합의 형태를 갖추고 있다.

// 20. 소프트웨어 아키텍처 모델 MVC(Model-View-Controller)
// (1) MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.
// (X) 모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브 시스템이 각각 하나씩 연결된다.
// (3) 뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.
// (4) 제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.
// <해설>
// - 한 개의 모델에 대해 여러 개의 뷰를 만들 수도 있다.
// - 모델은 서브 시스템의 핵심 기능과 데이터를 보관하며 MVC 패턴에서는 여러 개의 뷰를 만들 수 있으므로
// 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 어플리케이션에 적합하다.
// <용어 정리>
// - MVC : 사용자 인터페이스, 데이터 및 논리 제어를 구현하는 데 널리 사용되는 소프트웨어 디자인 패턴

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 소프트웨어 개발

// 21. 통합 테스트(Integration Test)
// (1) 시스템을 구성하는 모듈의 인터페이스와 결함을 테스트하는 것이다.
// (2) 하향식 통합 테스트의 경우, 넓이 우선(Breath-First) 방식으로 테스트를 할 모듈을 선택할 수 있다.
// (X) 상향식 통합 테스트의 경우, 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.
// (4) 모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘 되고 있는지를 빨리 파악하고자할 때 상향식보다는 하향식 통합 테스트를 사용하는 것이 좋다.
// <해설>
// - 상향식 통합 테스트(Bottom-Up Integration Test)
// 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합
// 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster) 필요
// - 하향식 통합 테스트(Top-Down Integration Test)
// 상위 모듈에서 하위 모듈 방향으로 통합
// 깊이 우선 통합법, 넓이 우선 통합법 사용
// 초기부터 사용자에게 시스템 구조를 보여줌

// 22. 이진 탐색 방법
// - 이진 탐색 동작 방식
// 1) 배열의 중간 값을 찾음.
// 2) 중간 값과 검색 값을 비교
// 2-1) 중간 값이 검색 값과 같으면 끝
// 2-2) 중간 값이 검색 값보다 작으면 오른쪽 구간을 탐색
// 2-3) 중간 값이 검색 값보다 크면 왼쪽 구간을 탐색
// 3) 값을 찾거나 간격이 비었을 때까지 반복

// 23. 소프트웨어 공학에서 워크스루(Walk-through)
// (1) 사용 사례를 확장하여 명세하거나 설계 다이어그램, 원시 코드, 테스트 케이스 등에 적용할 수 있다.
// (2) 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.
// (X) 인스펙션(Inspection)과 동일한 의미를 가진다.
// (4) 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해보는 것이다.
// <해설>
// - 워크스루(Walk-through) : 요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견.
// - 인스펙션(Inspection) : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견.

// 24. 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?
// (X) 복호화
// (2) 형상관리
// (X) 저작권
// (X) 크랙
// <해설>
// - 복호화 : 디코딩, 즉 부호화된 데이터를 부호화되기 전 형태로 바꾸어 사람이 읽을 수 있는 형태로 되돌려 놓은 것
// - 형상관리 : 소프트웨어의 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동
// - 저작권 : 창작물을 만든 이가 자신의 저작물에 대해 가지는 법적 권리
// - 크랙 : 소프트웨어를 수정하여 개발자가 원하지 않는 기능들, 보통은 수정 방식(복사 보호, 소프트웨어 조작 보호)을 비활성화하거나 제거하는 일

// 25. 테스트 케이스
// (X) 테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다.
// (2) 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다.
// (3) 개발된 서비스가 정의된 요구 사항을 준수하는지 확인하기 위한 입력 값과 실행 조건, 예상 결과의 집합으로 볼 수 있다.
// (4) 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다.
// <해설>
// - 테스트 케이스(Test Case)
// 구현된 소프트웨어가 사용자의 요구 사항을 정확하게 준수했는지를 확인하기 위해
// 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미한다.
// 테스트의 목표 및 테스트 방법을 결정하고 테스트 케이스를 작성해야 한다.
// <용어 정리>
// - 테스트 오라클(Test Oracle) : 테스트 실행 결과의 참/거짓 판별 기준

// 26. 객체지향 개념을 활용한 소프트웨어 구현
// (1) 객체(Object)란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재이다.
// (X) JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'이다
// (3) 상속(Inheritance)은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다.
// (4) 같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스(Instance)라고 한다.
// <해설>
// - JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 외부에서 클래스 내부 정보에 접근하지 못하도록 하는 '접근금지'이다.
// <용어 정리>
// - 정보은닉(or 은닉성) : 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해 접근을 허용하는 것으로, 클래스 외부에서 특정 정보에 접근을 막는다는 의미

// 27. DRM(Digital Rights Management)
// (1) 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다.
// (2) 디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리, 과금, 유통 단계를 관리하는 기술로도 볼 수 있다.
// (3) 클리어링 하우스(Clearing House)는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템을 말한다.
// (X) 원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다.
// <해설>
// - DRM(Digital Rights Management)
// 디지털 콘텐츠의 지적재산권보호, 관리 기능 및 안전한 유통과 배포를 보장하는 솔루션이다.
// 디지털 콘텐츠의 지적재산권을 보호하는 권한통제 기술, 사용권한제어 기술, 패키징 기술, 라이선스 관리를 포함한 유통 체계이다.
// 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다.
// <용어 정리>
// - DRM
// 출판자 또는 저작권자가 그들이 배포한 디지털 자료나 하드웨어의 사용을 제어하고 이를 의도한 용도로만 사용하도록 제한하는 데 사용되는 모든 기술들을 지칭하는 용어
// - 클리어링 하우스
// 디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 정산소로서 라이센서(licensor)와 라이센시(licensee)가 아닌 제3의 운영주체가 운영한다.

// 28. 위험 모니터링의 의미
// (X) 위험을 이해하는 것
// (X) 첫 번째 조치로 위험을 피할 수 있도록 하는 것
// (X) 위험 발생 후 즉시 조치하는 것
// (4) 위험 요소 징후들에 대하여 계속적으로 인지하는 것

// 29. 동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?
// (1) RCS(Revision Control System)
// (X) RTS(Reliable Transfer Service)
// (X) RPC(Remote Procedure Call)
// (X) RVS(Relative Version System)
// <해설>
// - RCS(Revision Control System)
// CVS와의 차이점은 소스 파일의 수정을 한 사람만으로 제한한다는 것이다.
// 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구이다.
// 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있다.
// - RPC(Remote Procedure Call)
// 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행할 수 있게 해주는 프로세스 간 통신
// <용어 정리>
// - RTS(Reliable Transfer Service, 안정적인 송금 서비스)
// - RVS(Relative Version System, 상대 버전 시스템)
// - CVS(Concurrent Version System, 동시 버전 관리 시스템)
// 소프트웨어 프로젝트를 진행할 때, 파일로 이뤄진 모든 작업과 모든 변화를 추적하고, 여러 개발자(지역적으로 떨어진)가 협력하여 작업할 수 있게 한다.

// 30. 화이트박스 테스트
// (1) 화이트박스 테스트의 이해를 위해 논리흐름도(Logic-Flow Diagram)를 이용할 수 있다.
// (2) 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트(Dynamic Test)에 해당한다.
// (X) 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다.
// (4) 테스트 데이터를 선택하기 위해 검증기준(Test Coverage)을 정한다.
// <해설>
// - 블랙박스 테스트 : 프로그램 구조를 고려하지 않는 테스트
// <용어 정리>
// - 정적 테스트 : 소프트웨어를 실행하지 않고 요구사항 정의서, 설계서, 소스 코드 등의 개발 산출물을 테스팅하는 것
// - 동적 테스트 : 실제 구현된 시스템(프로그램)을 실행하여 테스팅하는 것
// - 화이트박스 테스트 : 소프트웨어 또는 컴포넌트 등의 로직에 대한 테스트를 수행하기 위해 설계 단계에서 요구된 사항을 확인하는 개발자 관점의 단위테스팅 기법
// - 블랙박스 테스트 : 소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어의 동작을 검사하는 방법

// 31. 알고리즘
// (1) 주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것으로 볼 수 있다.
// (2) 검색(Searching)은 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당되는 데이터를 찾는 알고리즘이다.
// (3) 정렬(Sorting)은 흩어져있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘이다.
// (X) 선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.
// <해설>
// - 선형 검색(or 순차 탐색)
// 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색
// - 이진 검색
// 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.

// 32. 버블 정렬
// 버블 정렬은 첫번째 원소부터 마지막 원소까지 순서대로 바로 오른쪽 원소와 값을 비교해가면서 데이터를 정렬하는 기법이다.
// pass 1 : 첫 버블의 정렬이 끝난 상태
// <예시> 9, 6, 7, 3, 5 오름차순 버블 정렬 pass 1
// 9와 6을 비교 -> 69735 -> 9와 7을 비교 -> 67935 -> 9와 3을 비교 -> 67395 -> 9와 5를 비교 -> 67359

// 33. 인스펙션(Inspection) 과정
// 1) 계획
// 2) 사전 교육
// 3) 인스펙션 회의
// 4) 수정 -> 1) 계획
// 5) 후속 조치

// 34. 소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것은?
// <해설>
// (1) Refactoring - 결과의 변경 없이 코드의 구조를 재조정함
// (X) Architecting - 기능면에서 바라본 본 구성 방식. 구조, 밑그림(설계 관련)
// (X) Specification(규격, 사양) - 명세서
// (X) Renewal(갱신) - 유지보수
// - 리펙토링과 유지보수는 다른 개념이다.

// 35. 단위 테스트(Unit Test)
// (1) 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
// (2) 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
// (X) 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.
// (4) 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.
// <해설>
// - 테스트 드라이버(Test Driver)
// 상위 모듈의 역할을 하는 가상의 모듈로서 테스트할 모듈을 호출하는 역할을 한다.
// 즉, 필요한 데이터를 인자를 통해 넘겨주고 테스트가 완료된 후 그 결과값을 받는 역할을 한다.
// - 테스트 스텀(Test Stub)
// 테스트 완료 후 그 결과값을 받는 역할을 하는 가상 모듈.

// 36. IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명
// (1) Coding - 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성할 수 있는 환경을 제공
// (X) Compile - 저급언어의 프로그램을 고급언어 프로그램으로 변환하는 기능
// (3) Debugging - 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능
// (4) Deployment - 소프트웨어를 최종 사용자에게 전달하기 위한 기능
// <해설>
// - Compile : 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 기능
// - 컴파일은 고급언어(사람이 인식하는 언어)를 저급언어(기계어)로 변환하는 기능이다.

// 37. 후위 순회(Post-order Traverse)
// <해설>
// - 이진 나무 순회(Tree Traverse) 종류
// 1) 전위 순회(Pre-order Traverse)
// 뿌리(Root)를 먼저 방문 == Root, Left, Right 순서
// 2) 중위 순회(In-order Traverse)
// 왼쪽 하위 트리를 방문 후 뿌리(Root)를 방문 == Left, Root, Right 순서
// 3) 후위 순회(Post-order Traverse)
// 하위 트리 모두 방문 후 뿌리(Root)를 방문 == Left, Right, Root 순서
// 4) 층별 순회(Lever-order Traverse)
// 위 쪽 node들부터 아래 방향으로 차례로 방문 == node의 순서대로
// <용어 정리>
// - path : edge에 의해 연결된 node들의 집합
// - root node : 최상위의 node
// - parent(부모), children(자식), sibling(형제), grandparent(조부모), ancestor(조상)
// 기준이 되는 것의 바로 직계 상위 node를 부모, 바로 아래층의 node를 자식, 같은 부모를 둔 node들을 형제, 부모의 부모를 조부모, 직계 상위 노드들은 조상
// - leaf(잎) : 자식이 없는 node
// - subtree(하위 나무) : 큰 tree에 속한 작은 tree
// - node의 degree : 특정 node의 subtree 개수
// - node의 level : root node 부터 최하위 node까지의 중첩되지 않은 path의 node 개수

// 38. 인터페이스 구현 시 사용하는 기술로 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷은?
// (1) JSON
// (X) HTML
// (X) AVPN
// (X) DOF
// <해설>
// - JSON(JavaScript Object Notation)
// 속성-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷이다.
// AJAX(Asynchronous Javascript And Xml)에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷이다.
// 언어 독립형 데이터 포맷으로 다양한 프로그래밍 언어에서 사용되고 있다.
// <용어 정리>
// - DOF(Depth of Focus, 심도)
// - AJAX(Asynchronous Javascript And Xml) (asynchronous : 비동기적인)
// Ajax는 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법의 하나이다.
// Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다.
// 즉, Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시할 수 있다.

// 39. 순서가 있는 리스트에서 데이터의 삽입(Push), 삭제(Pop)가 한 쪽 끝에서 일어나며 LIFO(Last-In-First-Out)의 특징을 가지는 자료구조는?
// (X) Tree
// (X) Graph
// (3) Stack
// (X) Queue
// <해설>
// - Stack : LIFO(Last-In-First-Out), 한 쪽 끝에서 일어남
// - Queue : FIFO(First-In-First-Out), 양방향에서 일어남
// - Tree & Graph : 비선형 구조

// 40. 단위 테스트 도구
// (1) CppUnit
// (2) JUnit
// (3) HttpUnit
// (X) IgpUnit
// <해설>
// - CppUnit : C++ 프로그래밍 언어용 단위 테스트 도구
// - JUnit : 자바 프로그래밍 언어용 단위 테스트 도구
// - HttpUnit : 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크
// <용어 정리>
// - IgpUnit : 없는 단어

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 데이터베이스 구축

// 41. 다음 조건을 모두 만족하는 정규형은?
// - 테이블 R에 속한 모든 도메인이 원자값만으로 구성되어 있다.
// - 테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며, 키의 부분 집합이 결정자가 되는 부분 종속이 존재하지 않는다.
// - 테이블 R에 존재하는 모든 함수적 종속에서 결정자가 후보키이다.
// (1) BCNF
// (X) 제 1정규형
// (X) 제 2정규형
// (X) 제 3정규형
// <해설>
// 정규화 과정(도부이결다조)
// - 1NF : 모든 *도*메인이 원자 값으로만 구성
// - 2NF : 기본키가 아닌 속성이 기본키에 대한 완전 함수적 종속을 만족, *부*분적 함수 종속을 제거한 정규형
// - 3NF : 기본키가 아닌 모든 속성이 기본키에 대해 *이*행적 함수 종속 관계를 만족하지 않는 정규형
// - BCNF : 모든 *결*정자가 후보키인 정규형, 종속성 보존 X
// - 4NF : *다*치 종속이 성립하는 경우, R의 모든 속성이 A에 함수적 종속 관계를 만족
// - 5NF : 모든 *조*인 종속이 R의 후보키를 통해서만 성립되는 정규형
// <내용 정리>
// Relation-Normalization.js 참고

// 42. 데이터베이스의 트랜잭션 성질들 중에서 다음 설명에 해당하는 것은?
// - 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 원래 상태가 되도록 해야 한다.
// <해설>
// (1) Atomicity(원자성) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 함.
// (X) Consistency(일관성) : 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 함.
// (X) Isolation(격리성 or 고립성) : 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함.
// (X) Durability(영속성 or 지속성) : 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨.
// <용어 정리>
// - 트랜잭션(Transaction) : "쪼갤 수 없는 업무 처리의 최소 단위"를 말한다. 거래내역이라고도 한다.

// 43. 분산 데이터베이스 시스템
// (1) 물리적으로 분산된 데이터베이스 시스템을 논리적으로 하나의 데이터베이스 시스템처럼 사용할 수 있도록 한 것이다.
// (2) 물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 한다.
// (3) 분산 데이터베이스 시스템을 위한 통신 네트워크 구조가 데이터 통신에 영향을 주므로 효율적으로 설계해야 한다.
// (X) 데이터베이스가 분산되어 있음을 사용자가 인식할 수 있도록 분산 투명성(Distribution Transparency)을 배재해야 한다.
// <해설>
// - 분산 데이터베이스의 목표
// 1) 위치 투명성(Location Transparency)
// 하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요가 없다.
// 2) 중복(or 복제) 투명성(Replication Transparency)
// 사용자에게 통지할 필요없이 시스템 안에 파일들과 자원들의 부가적인 복사를 자유롭게 할 수 있다.
// 3) 병행 투명성(Concurrency Transparency)
// 다중 사용자들이 자원들을 공동으로 공유할 수 있다.
// 4) 장애 투명성(Failure Transparency)
// 사용자들은 어느 위치의 시스템에 장애가 발생했는지 알 필요가 없다.
// <내용 정리>
// Distributed-Database-System.js 참고

// 44. SQL 구문
// SELECT (속성명) FROM (테이블명) WHERE (조건) ORDERED BY (속성명 ASC(오름차순 : default) or DESC(내림차순))

// 45. 데이터베이스의 인덱스
// (1) 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조이다.
// (2) 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 된다.
// (X) 인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다.
// (4) 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다.
// <해설>
// - 인덱스(Index)
// 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며,
// 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 별도로 구성한 순서 데이터를 말한다.
// 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다.
// - 인덱스 생성 명령어 : CREATE
// - 인덱스 삭제 명령어 : DROP
// <용어 정리>
// - 클러스터(Cluster)
// 데이터베이스에서 클러스터란 여러개의 서버가 하나의 데이터베이스를 나눠서 처리하는 형태를 뜻한다.
// 고가용성, 병렬처리, 성능향상 이러한 3가지를 만족하는 시스템의 구성형태를 데이터베이스 클러스터라고 한다.
// 컴퓨터 클러스터란 여러 대의 컴퓨터들이 연결되어서 하나의 시스템처럼 동작하는 컴퓨터들의 집합을 말한다. 여러개의 객체를 하나로 모은다는 개념을 가지고 있다.
// DB 클러스터도 똑같은 맥락이다. DB 서버를 여러개 둔다고 생각하면 된다. 이에 대한 기본적인 장점은 서버 한 대가 죽어도 대비가 가능하다는 점이다.
// DB 클러스터와 비슷한 형태로 복수개의 독립된 DB가 서로 연계되는 경우가 있다. 이 DB는 서로 데이터를 읽거나 쓰는데, DBLink 또는 SQL/MED라고 한다.
// - DB 클러스터의 용도
// 1) 고가용성(High Availability)
// 서버와 네트워크, 프로그램 등의 정보 시스템이 상당히 오랜 기간 동안 지속적으로 정상 운영이 가능한 성질을 말한다.
// 고가용성이란 "가용성이 높다"는 뜻으로서, "절대 고장 나지 않음"을 의미한다.
// 2) 병렬처리(Analytic)
// DB를 복수개의 작은 단위로 분해해서 각각을 분석하여 처리하는 것
// 3) 성능향상(Online)
// DB 유저수가 막대해지는 케이스는, Web계 어플리케이션에서 자주 발생한다.
// 대규모 Web 어플리케이션의 경우 DB의 복사본을 만들어서 그 DB를 사용하게 하는 방법인 참조 처리로 유저수가 많아지는 것을 대비할 수 있다.

// 46. 물리적 데이터베이스 구조의 기본 데이터 단위인 저장 레코드 양식을 설계할 때 고려 사항
// (1) 데이터 타입
// (2) 데이터 값의 분포
// (X) 트랜잭션 모델링
// (4) 접근 빈도
// <해설>
// - 저장 레코드 양식 설계 시 고려 사항
// 데이터 타입, 데이터 값의 분포, 접근 빈도
// - 트랜잭션 모델링 : 개념적 설계 단계에서 한다.
// 트랜잭션을 개념적 시스템과 독립적으로 정의한다.
// 트랜잭션의 입출력 기능, 형태만 정의한다.
// 검색, 갱신, 혼합(검색 & 갱신)
// <내용 정리>
// - 데이터베이스 설계
// 1) 요구사항 분석
// 사용자의 요구사항을 수집, 분석하여 개발할 데이터베이스의 용도를 파악한다.
// 업무에 필요한 데이터, 데이터를 이용한 처리 방향 등을 고려한다.
// 결과물 : 요구사항 명세서
// 2) 개념적 설계
// DBMS에 독립적인 개념적 스키마 설계
// 요구사항 명세서를 개념적 구조로 표현한다.
// 결과물 : E-R 다이어그램(Entity-Relation Diagram)
// - E-R 다이어그램(Entity-Relation Diagram, ERD)
// 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델
// 개념적 모델링의 대표적인 도구
// 1대 1, 1대 다, 다대 다를 표현할 수 있고, ERD 표준기호와 새발 표기법을 사용하여 표기한다.
// 3) 논리적 설계
// DBMS에 적합한 논리적 구조 설계
// 결과물 : 논리적 스키마(릴레이션 스키마)
// 4) 물리적 설계
// DBMS로 구현 가능한 물리적 구조 설계
// 결과물 : 물리적 스키마
// 5) 구현
// 데이터베이스 생성

// 47. SQL 기능에 따른 분류 중에서 REVOKE문과 같이 데이터의 사용 권한을 관리하는 데 사용하는 언어는?
// (X) DDL(Data Definition Language)
// (X) DML(Data Manipulation Language)
// (3) DCL(Data Control Language)
// (X) DUL(Data User Language)
// <내용 정리>
// - DDL(Data Definition Language)
// 주로 데이터베이스 관리자나 데이터 베이스 설계자가 데이터베이스 스키마를 정의하거나 조작하기 위한 언어이다.
// 생성, 수정, 삭제 등의 데이터 전체 골격을 결정하는 역할을 담당한다.
// DDL의 데이터 정의어(CREATE, ALTER, DROP)
// 1) CREATE : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 정의
// 2) ALTER : TABLE에 대한 정의를 변경하는 데 사용
// 3) DROP : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 삭제
// - DML(Data Manipulation Language)
// 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어이다.
// 데이터 베이스 사용자와 데이터 베이스 관리 시스템 간의 인터페이스를 제공한다.
// DML 레코드 제어 명령어(SELECT, INSERT, DELETE, UPDATE)
// 1) SELECT : 테이블에서 조건에 맞는 튜플을 검색
// 2) INSERT : 테이블에 새로운 튜플을 삽입
// 3) DELETE : 테이블에서 조건에 맞는 튜플을 삭제
// 4) UPDATE : 테이블에서 조건에 맞는 튜플의 내용을 변경
// - DCL(Data Control Language)
// 객체 권한 부여 등의 제어어로 데이터의 보안, 무결성, 데이터 회복, 병행 수행 제어 등을 정의하는 데 사용하는 언어이다.
// 데이터 베이스 관리자가 데이터 관리를 목적으로 사용한다.
// DCL 데이터 제어어(COMMIT, ROLLBACK, GRANT, REVOKE)
// 1) COMMIT : 명령어로 수행된 결과를 실제 물리적 디스크로 저장하고, 명령어로 수행을 성공적으로 완료하였음을 선언한다.
// 2) ROLLBACK : 명령어로 수행을 실패하였음을 알리고, 수행된 결과를 원상복구시킨다.
// 3) GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.
// 4) REVOKE : 데이터베이스 사용자로부터 사용 권한을 취소한다.
// - DUL(Data User Language) : 없는 단어

// 48. 데이터 사전
// (1) 시스템 카탈로그 또는 시스템 데이터베이스라고도 한다.
// (X) 데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정할 수 있다.
// (3) 데이터베이스에 대한 데이터인 메타데이터(Metadata)를 저장하고 있다.
// (4) 데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보는 데이터 디렉토리(Data Directory)라는 곳에서 관리한다.
// <해설>
// - 데이터 사전(Data Dictionary, DD)
// 시스템 자신이 필요로 하는 여러가지 객체(기본 테이블, 뷰, 인덱스, 데이터베이스, 패키지, 접근 권한 등)에 관한 정보를 포함하고 있는 시스템 데이터베이스이다.
// 시스템 카탈로그(System Catalog), 메타 데이터(Meta Data)라고도 한다.
// 시스템 카탈로그 자체도 시스템 테이블로 구성되어 있어 SQL문을 이용하여 내용 검색이 가능하다.
// 사용자가 시스템 카탈로그를 직접 갱신할 수 없다.
// SQL문으로 여러가지 객체에 변화를 주면 시스템이 자동으로 갱신한다.

// 49. 데이터베이스에서 릴레이션
// (1) 모든 튜플은 서로 다른 값을 가지고 있다.
// (X) 하나의 릴레이션에서 튜플은 특정한 순서를 가진다.
// (3) 각 속성은 릴레이션 내에서 유일한 이름을 가진다.
// (4) 모든 속성 값은 원자 값(atomic value)을 가진다.
// <해설>
// - 튜플의 순서는 정해져있지 않다.

// 50. 데이터베이스에서의 뷰(View)
// (1) 뷰는 다른 뷰를 기반으로 새로운 뷰를 만들 수 있다.
// (2) 뷰는 일종의 가상 테이블이며, update에는 제약이 따른다.
// (3) 뷰는 기본 테이블을 만드는 것처럼 create view를 사용하여 만들 수 있다.
// (X) 뷰는 논리적으로 존재하는 기본 테이블과 다르게 물리적으로만 존재하며 카탈로그에 저장된다.
// <해설>
// - 뷰는 논리적으로만 존재한다.
// <내용 정리>
// -(데이터베이스에서) 뷰(View)
// 1) 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
// 2) 뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다.
// 3) 뷰는 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.
// 4) 뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다.
// - 뷰(View)의 특징
// 1) 뷰는 기본테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다.
// 2) 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다.
// 3) 데이터의 논리적 독립성을 제공할 수 있다.
// 4) 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
// 5) 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.
// 6) 기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야지만 삽입, 삭제, 갱신, 연산이 가능하다.
// 7) 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
// 8) 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.
// - 뷰(View) 사용시 장점
// 1) 논리적 데이터 독립성을 제공한다.
// 2) 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해 준다.
// 3) 사용자의 데이터관리를 간단하게 해준다.
// 4) 접근 제어를 통한 자동 보안이 제공된다.
// - 뷰(View) 사용시 단점
// 1) 독립적인 인덱스를 가질 수 없다.
// 2) ALTER VIEW문을 사용할 수 없다. 즉 뷰의 정의를 변경할 수 없다.
// 3) 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

// 51. 트랜잭션의 상태 중 트랜잭션의 마지막 연산이 실행된 직후의 상태로,
// 모든 연산의 처리는 끝났지만 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하지 않은 상태는?
// (X) Active
// (2) Partially Committed
// (X) Committed(처리)
// (X) Aborted(중단)
// <해설>
// - Partially Committed : 마지막 연산이 실행된 직후의 상태로 아직 Commit 연산 실행 전
// - Committed : 트랜잭션이 실행을 성공적으로 완료하여 Commit 연산을 수행한 상태
// - 트랜잭션 과정
// Active -> Partially Committed -> Committed
//                  ㅣㅡ> Failed -> Aborted(Rollback 연산)

// 52. SQL의 명령을 사용 용도에 따라 DDL, DML, DCL로 구분할 경우, 그 성격이 나머지 셋과 다른 것은?
// (X) SELECT
// (X) UPDATE
// (X) INSERT
// (4) GRANT
// <해설>
// - DML(Data Manipulation Language)
// 1) SELECT : 테이블에서 조건에 맞는 튜플을 검색
// 2) INSERT : 테이블에 새로운 튜플을 삽입
// 3) UPDATE : 테이블에서 조건에 맞는 튜플의 내용 갱신
// 4) DELETE : 테이블에서 조건에 맞는 튜플 삭제
// - DCL(Data Control Language)
// 1) COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료됐음을 알려주는 명령어
// 2) ROLLBACK : 아직 COMMIT되지 않은 변경된 모든 내용들을 취소하고, 데이터베이스를 이전 상태로 되돌리는 명령어
// 3) GRANT : 데이터베이스 사용자에게 사용 권한 부여
// 4) REVOKE : 데이터베이스 사용자의 사용 권한 취소
// - DDL(Data Definition Language)
// 1) CREATE : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 정의
// 2) ALTER : TABLE에 대한 정의를 변경하는 데 사용
// 3) DROP : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 삭제

// 53. 키의 종류 중 유일성과 최소성을 만족하는 속성 또는 속성들의 집합은?
// (X) Atomic Key
// (X) Super Key(슈퍼키)
// (3) Candidate Key(후보키)
// (X) Test Key
// <해설>
// - Super Key(슈퍼키) : 속성들의 집합으로 구성된 키, 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다(유일성만 만족).
// - Candidate Key(후보키) : 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합(유일성, 최소성 만족)

// 54. 데이터베이스에서 개념적 설계 단계
// (1) 산출물로 E-R Diagram을 만들 수 있다.
// (2) DBMS에 독립적인 개념 스키마를 설계한다.
// (X) 트랜잭션 인터페이스를 설계 및 작성한다.
// (4) 논리적 설계 단계의 앞 단계에서 수행된다.
// <해설>
// - 데이터베이스 설계 단계에서의 트랜잭션 설계 단계
// 1) 개념 설계
// 트랜잭션 모델링, 독립적인 개념 스키마 모델링, 개념 스키마 설계, E-R Diagram
// 2) 논리 설계
// 트랜잭션 인터페이스 설계, DBMS에 맞는 논리 스키마 설계, 테이블 설계, 논리적 매핑, 스키마 평가 및 정제
// 3) 물리 설계 : 트랜잭션 세부 설계
// 레코드에 초점을 맞춘 분석 및 설계, 저장 레코드 양식 설계, 저장 구조 및 액세스 경로 설정

// 55. 테이블의 기본키(Primary Key)로 지정된 속성
// (1) NOT NULL로 널 값을 가지지 않는다.
// (2) 릴레이션에서 튜플을 구별할 수 있다.
// (3) 외래키로 참조될 수 있다.
// (X) 검색할 때 반드시 필요하다.
// <해설>
// - 기본키 설명
// 후보키 중에서 선정된 주키(MAIN KEY)로 중복된 값을 가질 수 없다.
// 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다(유일성).
// 기본키는 후보키의 성질을 갖는다(유일성, 최소성). 즉, 튜플을 식별하기 위해 반드시 필요한 키
// 기본키는 NULL 값을 가질 수 없다. 즉, 기본키로 설정된 속성에는 NULL 값이 있어서는 안된다.

// 56. 데이터 모델의 구성요소 중 데이터 구조에 따라 개념 설계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?
// (X) Relation
// (X) Data Structure
// (X) Constraint
// (4) Operation
// <해설>
// - 데이터 모델 정의
// 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화한 체계적인 개념적 모형을 말한다.
// 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 사용되는 지능적인 도구
// - 데이터 모델의 구성 요소
// 1) 개체(Entity) : 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
// 2) 속성(Attribute) : 가장 작은 논리적 단위, 데이터 항목, 데이터 필드
// 3) 관계(Relationship) : 개체 간의 관계, 속성 간의 논리적인 연결
// - 데이터 모델 종류
// 1) 개념적 데이터 모델
// 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정.
// 대표적인 개념적 데이터 모델로는 E-R 모델이 있다.
// 2) 논리적 데이터 모델
// 개념적 모델링 과정에서 얻은 구조를 컴퓨터가 이해하고 처리할 수 있게 변환하는 과정.
// '정규화' 작업이 논리적 데이터 모델링에 해당한다.
// 3) 물리적 데이터 모델
// 실질적 데이터 구조 설계로, 테이블 정의서, 명세서 등이 있다.
// - 데이터 모델에 표시할 요소
// 1) 구조(Structure) : 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현
// 2) 연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
// 3) 제약조건(Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약조건

// 57. SQL문 SELECT
// SELECT (속성) FROM (테이블) WHERE (조건)
// 문제 : 이름이 '정도일'인 팀원이 소속된 팀코드를 이용하여 해당 팀에 소속된 팀원들의 이름을 출력하는 SQL문 작성
// 테이블 : 직원, 속성 : 팀코드, 이름
// SELECT 이름 FROM 직원 WHERE (팀코드 = (SELECT 팀코드 FROM 직원 WHERE 이름 = '정도일'))

// 58. 무결성 제약조건 중 개체 무결성 제약조건
// (X) 릴레이션 내의 튜플들이 각 속성의 도메인에 정해진 값만을 가져야 한다.
// (2) 기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다.
// (X) 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 한다.
// (X) 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다.
// <해설>
// - 기본키(Primary Key)
// 테이블의 각 레코드를 고유하게 식별하는 필드나 필드의 집합이다.
// 테이블에 기본키 설정을 필수가 아니다.
// 기본키를 설정하지 않고도 다른 테이블과의 관계를 설정할 수 있다.
// 기본키는 혼합 속성(다수 필드)에 설정할 수 있다.
// - 데이터 무결성(Data Integrity) 제약조건(Constraint) 종류
// 1) 개체 무결성(Entity Integrity)
// 기본키 제약이라고도 하며, 테이블은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 하는 조건이다.
// 기본키에는 NULL 값이 올 수 없다.
// 기본키는 테이블 내에 오직 하나의 값만 존재해야 한다(하나의 테이블 내에 동일한 기본키를 가진 레코드는 존재할 수 없음).
// 2) 참조 무결성(Referential Integrity)
// 외래키 제약이라고도 하며, 테이블 간의 참조 관계를 선언하는 제약조건
// 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다.
// 외래키 속성은 참조할 수 없는 값을 지닐 수 없다(외래키 속성값이 상위 테이블의 인스턴스에 반드시 존재하거나 NULL이어야 함).
// 3) 도메인 무결성(Domain Integrity)
// 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로, 필드의 타입, NULL 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 조건
// 예를 들어, 주민등록번호 필드에 문자가 입력되는 경우에는 도메인 무결성이 깨졌다고 볼 수 있다.
// 속성들의 값은 정의된 도메인에 속한 값이어야 한다.
// 4) 고유 무결성
// 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들이 서로 달라야 하는 조건
// 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 한다.
// 5) NULL 무결성
// 테이블의 특정 속성 값이 NULL 값이 될 수 없게 하는 조건
// 릴레이션의 특정 속성 값은 NULL 값이 될 수 없다.
// 6) 키 무결성
// 하나의 테이블에 적어도 하나의 키가 존재해야 하는 조건
// 각 릴레이션은 최소한 한 개 이상의 키가 존재해야 한다.
// - 무결성 제약조건 장점
// 스키마를 정의할 때 일관성 조건을 오직 한 번만 명시하고,
// 데이터베이스가 갱신될 때 DBMS가 자동으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없다.
// - 무결성 제약조건 단점
// 무결성 제약조건을 반복해서 구현해야 하므로 프로그래밍 작업이 훨씬 복잡해지고, 무결성 제약조건들 간에 서로 충돌이 발생할 수 있다.
// <용어 정리>
// - 개체(Entity) : 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 단위이다.
// - 무결성(Integrity) : 데이터의 정확성과 일관성을 유지하고 보증하는 것을 가리키며 데이터베이스나 RDBMS 시스템의 중요한 기능이다.
// - 정확성(Correctness) : 중복이나 누락이 없는 상태
// - 일관성(Consistency) : 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태

// 59. 관계 데이터베이스 모델에서 릴레이션(Relation)에 포함되어 있는 튜플(Tuple)의 수를 무엇이라고 하는가?
// (X) Degree
// (2) Cardinality
// (X) Attribute
// (X) Cartesian product
// <해설>
// - 차수(Degree) : 속성의 수(열의 개수)
// - 카디널리티(Cardinality) : 튜플의 수(행의 개수)
// - 속성(Attribute) : 릴레이션에서 열
// - 카테시안 곱(Cartesian product)
// From절에 2개 이상의 Table이 있을때 두 Table 사이에 유효 join 조건을 적지 않았을때,
// 해당 테이블에 대한 모든 데이터를 전부 결합하여 Table에 존재하는 행 갯수를 곱한 만큼의 결과값이 반환되는 것이다.

// 60. SQL문 GRANT
// 문제1 : 사용자 'PARK'에게 테이블을 생성할 수 있는 권한을 부여하기 위한 SQL문
// GRANT CREATE TABLE PARK;
// SQL문 의미 : PARK에게 [CREATE TABLE] 권한을 부여한다.
// 문제2 : 사용자 'PARK'에게 테이블을 생성할 수 있는 권한을 취소하기 위한 SQL문
// REVOKE CREATE TABLE FROM PARK;
// SQL문 의미 : PARK으로부터 [CREATE TABLE] 권한을 취소한다.

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 프로그래밍 언어 활용

// 61. C언어에서 문자열 처리 함수의 서식과 그 기능
// (1) strlen(s) - s의 길이를 구한다.
// (2) strcpy(s1, s2) - s1을 s2로 복사한다.
// (X) strcmp(s1, s2) - s1과 s2를 연결한다.
// (4) strrev(s) - s를 거꾸로 변환한다.
// <해설>
// - strcat(s1, s2) : s1과 s2를 연결한다(문자열 연결 함수).
// - strcmp(s1, s2) : s1과 s2를 비교하여 같다면 0, 다르다면 (s1의 아스키코드 - s2의 아스키코드)의 결과에 따라 -1 또는 1을 반환한다.(문자열 비교 함수)

// 62. C언어 프로그램
// && : and 연산
// || : or 연산
// ! : not 연산
// - C언어에서 true는 0이 아닌 수, false는 0으로 간주된다.

// 64. IP 프로토콜에서 사용하는 필드
// (1) Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
// (X) Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 2^32 - 1비트이다.
// (3) Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
// (4) Version Number는 IP 프로토콜의 버전번호를 나타낸다.
// <해설>
// - Total Packet Length(16bits)
// IP 헤더 및 데이터를 포함한 IP 패킷 전체의 길이를 바이트 단위로 표시(최대값은 2^16 - 1 = 65,535)
// <내용 정리>
// - 프로토콜(Protocol)
// 복수의 컴퓨터 사이나 중앙 컴퓨터와 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약.
// 신호 송신의 순서, 데이터의 표현법, 오류 검출법 등을 정함.
// - 헤더(Header)
// 데이터 앞 부분에 파일에 대한 정보를 실어놓은 부분
// 주로 데이터 형식에 대한 정보나 시간 데이터, 주소 데이터로 구성되어 있고 데이터의 종류에 따라 정리되기 쉽게 규격화해 놓은 데이터이다.
// 각 레이어는 아래 위로 인접한 층과 연계하여 통신을 처리한다.
// - 패킷(Packet)
// 네트워크를 통해 전송하기 쉽도록 자른 데이터의 전송 단위이다.
// 본래는 소포를 뜻하는 용어로, 소화물을 뜻하는 패키지(package)와 덩어리를 뜻하는 버킷(bucket)의 합성어이다.
// - IP(Internet Protocol) : 인터넷이 통하는 네트워크에서 어떤 정보를 수신하고 송신하는 통신에 대한 규약

// 66. RIP 라우팅 프로토콜
// (1) 경로 선택 메트릭은 홉 카운트(hop count)이다.
// (X) 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.
// (3) 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용한다.
// (4) 각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우터 표를 갱신한다.
// <해설>
// - RIP(Routing Information Protocol)
// 거리 벡터 라우팅 프로토콜
// 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 IGP에 해당한다.
// 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용한다.
// 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP를 선택한 경로가 최적의 경로가 아닌 경우가 종종 발생할 수 있다.
// 소규모 네트워크 환경에 적합하다.
// 최대 홉 카운트를 15홉 이하로 한정하고 있다.
// <내용 정리>
// - Routing-Protocol.js 참고

// 67. 다음에서 설명하는 프로세스 스케줄링은?
// - 최소 작업 우선(SJF) 기법의 약점을 보완한 비선점 스케줄링 기법으로 다음과 같은 식을 이용해 우선순위를 판별한다.
// - 우선순위 = (대기한 시간 + 서비스를 받을 시간) / (서비스를 받을 시간)
// (X) FIFO 스케줄링
// (X) RR 스케줄링
// (X) HRN 스케줄링
// (X) MQ 스케줄링
// <해설>
// - HRN(Highest Response Ratio Next) 스케줄링 방식(비선점 스케줄링)
// 실행시간이 긴 프로세스에 불리한 SJF(Shortest Job First)를 보완하기 위해 대기시간 및 서비스 시간을 이용한다.
// SJF 방식의 시간이 오래 걸리는 작업과 빨리 끝나는 작업 간의 지나친 불평등을 해소할 수 있다.
// 시스템 응답시간 = (대기한 시간 + 서비스 시간( == 실행 시간)) / (서비스 시간)
// 시스템 응답시간을 계산하여 숫자가 큰 것부터 작은 순으로 순위를 부여한다(시스템 응답시간 값이 클수록 우선순위가 높음).
// <내용 정리>
// - Scheduling.js 참고

// 68.

// 69.

// 70.

// 73.
//

// 75.

// 76.
//

// 77.

// 78.

// 79.

// 80.
//

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 정보시스템 구축관리

// 81.

// 82.

// 83.

// 84.

// 85.

// 86.

// 87.

// 88.

// 89.

// 90.

// 91.

// 92.

// 93.

// 94.

// 95.

// 96.

// 97.

// 98.

// 99.

// 100.

//-------------------------------------------------------------------------------------------------------------------------------------------------
