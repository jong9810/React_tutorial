// - 프로토콜(Protocol)
// 일반적으로 프로토콜은 외교상의 언어로써 의례나 국가간에 약속을 의미한다.
// IT 분야에서 프로토콜 또는 통신규약의 사전적인 의미는 컴퓨터나 원커리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다.
// 컴퓨터 간의 서로 이해 할 수 있는 언어 즉, 공용된 언어를 사용해야 하는데 이것이 바로 프로토콜(Protocol)이다.
// 통신에서는 어떤 시스템이 다른 시스템과 통신을 원할하게 수용하도록 해주는 통신 규약, 약속.

// - 프로토콜의 요소
// 1) 구문(Syntax) : 데이터의 형식이나 신호로, 부호화 방법 등을 정의한다.
// 2) 의미(Semantics) : 오류 제어, 동기 제어, 흐름 제어 같은 각종 제어 절차에 관한 제어 정보를 의미한다.
// 3) 순서(Timing) : [1]송/수신자 간, 혹은 [2]양단(End-toEnd)의 통신 시스템과 망, 사이의 통신 속도나 순서 등을 정의한다.

// - 프로토콜의 기능
// (1) 세분화(or 단편화)와 재합성
// 데이터의 크기와 종류는 다양하기 때문에 대용량 크기의 파일은 그대로 전송할 수가 없다.
// 따라서 이를 작은 단위로 나누어 보내고 수신측에서는 재조합해야 한다.
// (2) 캡슐화
// PDU(Protocol Data Unit) : 프로토콜 데이터 단위, 데이터가 전송될 때 일정 크기의 데이터 블록을 말한다.
// SDU(Service Data Unit) : 전송하려는 데이터를 의미한다.
// PCI(Protocol Control Information)
// 보통은 제어 정보를 의미한다. 주소, 오류 검출 코드, 프로토콜 제어 정보 등을 포함한다.
// PCI와 같은 정보를 모아놓는 것을 캡슐화라고 한다.
// PDU는 SDU와 PCI로 구성되어 있다.
// (3) 연결제어
//   - 연결 지향성 데이터 전송(Connection Oriented Data Transfer)
//     두 시스템이 서로 데이터를 교활할 때 연결을 설정하는 경우, 연결 설정, 데이터 전송, 연결 해제 3단계로 구성된다(ex. TCP).
//   - 비연결 지향성 데이터 전송(Connectionless Oriented Data Transfer)
//     두 시스템이 서로 데이터를 교활할 때 연결을 설정하지 않는 경우이다(ex. UDP).
//     이렇게 전송되는 데이터를 '데이터그램'이라고 한다.
// (4) 오류제어
// - 패리티 비트(Parity Bit)
// 정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가된 비트.
// - 잉여도 검사 or 순환 중복 검사(Cyclic Redundancy Check, CRC)
// 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식을 말한다.
// SDU나 PCI가 잘못되었을 경우 이를 발견하는 기법이다.
// 패리티 비트, 잉여도 검사를 통해 발견할 수 있다.
// 순서 검사나 일정 시간 안에 패킷을 받지 못하면 재전송을 요구하는 방식으로 이루어진다.
// (5) 흐름제어
// 송신측 개체로부터 오는 데이터의 양이나 속도를 조절하는 기능이다.
// - 정지-대기(Stop and Wait) 방법 : 패킷에 대한 응답 후에 다음 패킷을 보낸다.
// - 슬라이딩 윈도우(Sliding Window) 방법
// 가용 데이터 분량의 패킷을 한꺼번에 보낸 후 응답 패킷을 받으면 다시 그만큼 데이터를 한꺼번에 보내는 방식이다.
// (6) 동기화
// 데이터를 전송할 때 각 개체는 타이머 값이나 윈도우 크기 등을 기억해야 하는데, 이런 값을 공유하는 것을 말한다.
// (7) 순서 결정
// PDU가 전송될 때 보내어지는 순서를 명시하는 기능이며, 연결 지향형에만 사용된다.
// 순서를 지정하는 이유는 흐름 제어, 오류 제어 등을 위해서이다.
// PDU를 상대에게 보내면 상대는 순서에 맞게 데이터를 재구성하고 오류가 있을 시에는 재전송을 요청한다.
// (8) 주소 설정
// 한 개체가 다른 개체에 데이터를 전송하려 상대의 이름을 알아야 하는데, 프로토콜에는 각 전송 계층에 맞는 주소를 지정하는 기능이 있다.
// (9) 다중화
// 통신 선로 하나에서 여러 시스템이 동시에 통신할 수 있는 것을 말한다.
// (10) 전송 서비스
// 우선순위 결정, 서비스 등급과 보안 요구 등을 제어하는 서비스를 말한다.

// - 프로토콜의 특성에 따른 분류
// (1) 직접/간접(Direct/Indirect) 프로토콜
// - 직접 방식 : 2개의 개체 사이에 직접 정보를 교환하는 방식으로 점대점 방식, 멀티포인트/방송망(다점) 방식이 있다.
// - 간접 방식 : 교환망이나 다른 네트워크를 통해서 간접적으로 정보를 교환하는 방식으로 교환망 방식이 있다.
// (2) 단일체/구조체(Monolithic/Structured) 프로토콜
// - 단일체 : 개체 사이에 통신 작업이 하나의 프로토콜에서 이루어진다.
// - 구조체 : 복잡한 통신 작업을 처리하기 위해 프로토콜 층을 이루는 구조를 사용한다(전체적인 기능을 여러 개의 작은 기능으로 분리함).
// (3) 표준/비표준(Standard/Nonstandard) 프로토콜
// - 표준 : 컴퓨터 모델에 관계없이 프로토콜을 공유한다.
// - 비표준 : 특정한 통신 상황의 특정한 컴퓨터 모델에서 사용한다.
// - 프로토콜 표준화의 필요성
// 표준 프로토콜을 사용할 경우 누가 만들더라도 서로 통신이 가능하다.
// - 대표적인 표준화 기구
// 1) ISO(International Standardization Organization, 국제표준화기구)
// 공업규격의 국제적 통일과 조정을 목적으로 하는 비조약 기구이다.
// 2) ITU(International Telecommunication Union, 국제전기통신연합)
// UN의 자문기구로 전기통신 업무에 관한 규칙을 제정하고 권고안을 작성하는 연합이다.
// 3) ANSI(American National Standard Institute, 미국표준협회)
// 미국의 공업 분야에 있어서 규격의 통일과 표준화를 목적으로 설립되었다.
// 4) EIA(Electronic Industries Association, (미국의)전자공업연맹)
// 주로 통신용 하드웨어에 관한 규격을 제정한다.
// 5) IEEE(Institute of Electrical Electronics Engineers, (미국의)전기전자기술자협회)
// 미국의 전기, 전자 기술자로 구성된 협의체로 통신 분야에서는 주로 LAN표준을 제정합니다.
// (4) 물리적/논리적(Physical/Logical) 프로토콜
// - 물리적 측면
// 자료 전송에 쓰이는 전송 매체, 접속용 단자 및 전송 신호, 회선 규격 등을 가리킨다.
// 물리 계층, 데이터 링크 계층, 네트워크 계층이 물리적 측면에 속한다.
// - 논리적 측면
// 프레임(Frame, 자료의 표현 형식 단위) 구성, 프레임 안에 있는 각 항목의 뜻과 기능, 자료 전송의 절차 등을 가리킨다.
// 전송 계층, 세션 계층, 표현 계층, 응용 계층이 논리적 측면에 속한다.
// 1) 폐쇄적인 프로토콜
// 자사 장치들끼리 통신하기 위한 독자적인 통신 규약이며, 자세한 규격이 공개되어 있지 않아서 크래킹 위협에 상대적으로 안전하다.
// ex) IBM의 SNA, SDLC 프로토콜 등
// 2) 공개된 범용 프로토콜
// 여러 장치들에 쓰인는 널리 알려진 규약이며, 규격이 널리 공개되어 있기 때문에 컴퓨터와 네트워크 크래킹에 상대적으로 취약하다.
// ex) 인터넷의 TCP/IP 등

// - OSI 7계층 요약
// 7계층 : 응용 계층(application) : 사용자 인터페이스를 제공하는 계층
// 6계층 : 표현 계층(presentation) : 데이터의 변환 작업을 하는 계층
// 5계층 : 세션 계층(session) : 응용 프로그램 간의 연결을 지원해주는 계층
// 4계층 : 전송 계층(transport) : 서비스를 구분하고 데이터의 전송 방식을 담당하는 계층(TCP/UDP)
// 3계층 : 네트워크 계층(network) : 네트워크를 논리적으로 구분하고 연결하는 계층(IP)
// 2계층 : 데이터 링크 계층(data Link) : 물리적 매체에 패킷 데이터를 실어 보내는 계층
// 1계층 : 물리 계층(physical) : 신호로 변환하여 전송하는 계층

// - OSI 모형(Open Systems Interconnection Reference Model)
// 컴퓨터 통신 분야에서 다양한 표준에 대한 국제적인 표준 정의를 위한 기본 골격이다.
// 각 계층에서 표준이 개발, 발전될 수 있도록 기본틀을 제공하며, 절대적인 것이 아니고 기본 골격에 불과하다.
// 각 계층들은 순서대로 쌓여, 하위 계층은 상위 계층보다 추상화된 기능을 제공하며 상위 계층은 하위 계층의 기능을 이용하여 자체 기능을 구현한다.
// 상위 계층이란 보통 5, 6, 7계층을 말하며 이들 계층들은 네트워킹과 관련된 주소체계, 데이터 전달, 네트워크 구조 등과는 별로 관련이 없고,
// 주로 소프트웨어적인 응용 처리들만을 다루는 계층을 지칭하게 된다.
// 국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다(일반적으로 OSI 7 계층이라고 함).
// 과거 여러 정보 통신 업체들은 자사 장비 간의 연결만 지원하고 타사 장비와의 호환성은 지원하지 않았다.
// 이에 1984년 ISO에서 상호 이질적인 네트워크 간의 연결에 호환성 결여를 막기 위해 OSI 모델을 제시했다.
// OSI 모델은 네트워크를 이루고 있는 구성요소들을 7단계의 계층적 방법으로 나누고, 각 계층의 표준을 정한 것이다.
// OSI 7 계층의 목적은 표준화를 통하여 장비별로 이질적인 포트, 프로토콜의 호환 문제를 해결하고,
// OSI 모델을 이용하여 네트워크 시스템에서 일어나는 일을 쉽게 설명할 수 있게 하는 것에 있다.
// 또한 네트워크 관리자가 문제가 발생 했을 때 물리적인 문제인지, 응용 프로그램과 관련이 있는지 등 원인이 어디에 있는지 범위를 좁혀 쉽게 파악할 수 있게 한다.
// 응용 계층(Application Layer), 표현 계층(Presentation Layer), 세션 계층(Session Layer), 전송 계층(Transport Layer), 네트워크 계층(Network Layer),
// 데이터링크 계층(DataLink Layer), 물리 계층(Physical Layer)으로 구성되어 있다
// - OSI 7계층
// (1) 7계층 : 응용 계층(Application Layer)
// OSI 7계층 모델에서 최상위 계층으로 사용자가 네트워크 자원에 접근하는 방법을 제공한다.
// 계층 7은 최종적으로 사용자가 볼 수 있는 유일한 계층으로 모든 네트워크 활동의 기반이 되는 인터페이스를 제공한다.
// 즉, 사용자가 실행하는 응용 프로그램들이 계층 7에 속한다고 보면 된다(사용자와 가장 가까운 계층임).
// 예를 들면 가상 터미널인 텔넷(telnet), 구글의 크롬(chrome), 이메일(전자우편), 데이터베이스 관리 등의 서비스를 제공한다.
// - 단위(PDU) : Data
// - 예시 : 구글 크롬, 이메일, 데이터베이스 관리 등
// - 프로토콜 : HTTP, SMTP, SSH, FTP, Telnet, DNS, modbus, SIP, AFP, APPC, MAP

// (2) 6계층 : 표현 계층(Presentation Layer)
// 응용 계층으로부터 전달받은 데이터를 읽을 수 있는 형식으로 변환하는데 표현 계층은 응용 계층의 부담을 덜어주는 역할을 하기도 한다.
// 응용 계층으로부터 전송받거나 응용 계층으로 전달해야 할 데이터의 인코딩과 디코딩이 이 계층에서 이루어진다.
// 데이터를 안전하게 사용하기 위해서 암호화와 복호화를 하는데 이 작업도 표현 계층에서 이루어진다.
// 예를 들면 유니코드(UTF-8)로 인코딩 되어있는 문서를 ASCII로 인코딩 된 문서로 변환할 때, 표현 계층에서 변환이 이루어진다.
// - 단위(PDU) : Data
// - 예시 : 인코딩, 디코딩, 암호화, 복호화 등
// - 프로토콜 : ASCII, MPEG, JPEG, MIDI, EBCDIC, XDR, AFP, PAP

// (3) 5계층 : 세션 계층(Session Layer)
// 두 컴퓨터 간의 대화나 세션을 관리하며, 포트(Port)연결이라고도 한다.
// 모든 통신 장치 간에 연결을 설정, 관리 및 종료한다.
// 연결이 전이중(Full duplex, 양방향)인지 반이중(half duplex, 단방향)인지 여부를 확인하고 체크 포인팅과 유휴, 재시작 과정 등을 수행하여
// 호스트가 갑자기 중지되지 않고 정상적으로 호스트를 연결하는 역할을 한다.
// 즉 이 계층에서는 TCP/IP 세션을 만들고 없애고, 통신하는 사용자들을 동기화하고, 오류 복구 명령들을 일괄적으로 다루어
// 통신을 하기 위한 세션을 확립, 유지, 중단하는 작업을 수행한다.
// - 단위(PDU) : Data
// - 프로토콜 : NetBIOS, SAP, SDP, PIPO, SSL, TLS, NWLink, ASP, ADSP, ZIP, DLC

// (4) 4계층 : 전송 계층(Transport Layer)
// 전송 계층의 주목적은 하위 계층에 신뢰할 수 있는 데이터 전송 서비스를 제공하는 것이다.
// 컴퓨터와 컴퓨터 간에 신뢰성 있는 데이터를 서로 주고받을 수 있도록 해주어 상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 부담을 덜어준다.
// 이때 시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
// 흐름 제어, 분할/분리 및 오류 제어를 통해 전송 계층은 데이터가 오류 없이 점-대-점으로 전달되게 하는데,
// 신뢰할 수 있는 데이터 전송을 보장하는 것은 매우 번거롭기에 OSI 모델은 전체 계층을 사용한다.
// 전송 계층은 연결형 프로토콜과 비 연결형 프로토콜을 모두 사용한다.
// - 단위(PDU) : TCP-Segment, UDP-Datagram
// - 예시 : 특정 방화벽 및 프록시 서버 등
// - 프로토콜 : TCP, UDP, SPX, SCTP, NetBEUI, RTP, ATP, NBP, AEP, OSPF

// (5) 3계층 : 네트워크 계층(Network Layer)
// - 라우팅 : 어떤 네트워크 안에서 통신 데이터를 짜여진 알고리즘에 의해 최대한 빠르게 보낼 최적의 경로를 선택하는 과정.
// 네트워크 계층은 2홉 이상의 통신(멀티 홉 통신)을 담당한다.
// OSI 7 계층에서 가장 복잡한 계층 중 하나로서 실제 네트워크 간에 데이터 라우팅을 담당한다.
// 네트워크 계층은 네트워크 호스트의 논리 주소 지정(ex. ip 주소 사용)을 확인한다.
// 또한 데이터 스트림을 더 작은 단위로 분할하고 경우에 따라 오류를 감지해 처리한다.
// 그리고 여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할을 하는 계층으로,
// 다양한 길이의 데이터를 네트워크들을 통해 전달하고 그 과정에서 전송 계층이 요구하는 서비스 품질을 제공하기 위한 기능적, 절차적 수단을 제공한다.
// 네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션, 오류제어, 인터네트워킹 등을 수행한다.
// 라우터가 3계층에서 동작하고, 3계층에서 동작하는 스위치도 있다.
// 단위(PDU) : Packet
// 예시 : 라우터
// 프로토콜 : IP, IPX, IPsec, ICMP, ARP, NetBEUI, RIP, BGP, DDP, PLP

// (6) 2계층 : 데이터 링크 계층(Data Link Layer)
// - 홉(hop) : 컴퓨터 네트워크에서 노드에서 다음 노드로 가는 경로를 말한다.
// - 1홉 통신 : 한 라우터에서 그다음 라우터까지의 경로를 말한다.
// 데이터 링크 계층은 포인트 투 포인트 간의 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요하다.
// 네트워크 위의 개체들 간 데이터를 전달하고 물리 계층에서 발생할 수 있는 오류를 찾아내고 수정하는 데 필요한 기능적, 절차적 수단을 제공한다.
// 주목적은 물리적인 장치를 식별하는 데 사용할 수 있는 주소 지정 체계를 제공하는 것이다.
// 물리적인 네트워크를 통해 데이터를 전송하는 수단을 제공한다(1홉 통신을 담당함).
// 데이터 링크 계층의 예시로는 브리지 및 스위치 그리고 이더넷 등이 있다.
// - 단위(PDU) : Frame
// - 예시 : MAC 주소, 브리지 및 스위치 등
// - 프로토콜 : Ethernet, Token Ring, Apple Talk, PPP, ATM, MAC, HDLC, FDDI, LLC, ALOHA

// (7) 1계층 : 물리 계층(Physical Layer)
// OSI 모델의 맨 밑에 있는 계층으로서, 네트워크 데이터가 전송되는 물리적인 매체이다.
// 데이터는 0과 1의 비트열로 ON, OFF의 전기적 신호 상태로 이루어져 있다.
// 물리 계층은 전압, 허브, 네트워크 어댑터, 중계기 및 케이블 사양을 비롯해 사용된 모든 하드웨어의 물리적 및 전기적 특성을 정의한다.
// 물리 계층은 연결을 설정 및 종료하고 통신 자원을 공유하는 수단을 제공하며 디지털에서 아날로그로 또는 그 반대로 신호를 변환하는 역할을 한다.
// OSI 모델에서 가장 복잡한 계층으로 간주된다.
// - 단위(PDU) : Bit
// - 예시 : 전압, 허브, 네트워크 어댑터, 중계기 및 케이블 사양, 신호 변경(디지텅, 아날로그) 등
// - 프로토콜 : 10BASE-T, 100BASE-TX, ISDN, wired, wireless, RS-232, DSL, Twinax

// - TCP/IP 4계층
// http://wiki.hash.kr/index.php/TCP/IP
// TCP/IP는 문자 그대로는 전송제어 프로토콜, 인터넷 프로토콜을 의미한다.
// 보통 TCP/IP라고 말하면 이는 계층3, 계층4 프로토콜만 얘기하는 것이 아니라 TCP/IP 프로토콜 조합(protocol suit)을 의미하는 경우가 대부분이며,
// 오늘날 인터넷을 움직이는 통신 소프트웨어의 뼈대가 되는 모든 프로토콜을 말한다.
// 수많은 프로그램들이 인터넷으로 통신하는데 기반이 되는 프로토콜이다.
// 아파넷(ARPANET)이 개발되고 인터넷이 발전해나가는 과정에서 대부분의 데이터 통신이 TCP와 IP 기반으로 이루어졌기 때문에
// 다양한 프로토콜이 개발된 시점에서도 사실상 인터넷 프로토콜을 대표하는 용어로 사용 중이다.
// 이를 이용해서 컴퓨터를 연결하는 체계를 이더넷(Ethernet)이라고 부른다.
// TCP/IP 4 계층의 목적은 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 인터넷 표준 프로토콜을 만드는 것에 있다.
// 또한, OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 현실화의 과정에서 채택된 모형이다.
// 응용 계층(Application Layer), 전송 계층(Transport Layer), 인터넷 계층(Internet Layer), 네트워크 액세스 계층(Network Access Area Layer)으로 구성된다.

// - TCP/IP
// (1) TCP(Transport Control Protocol)
// TCP는 전송제어 프로토콜로서, 근거리 통신망이나 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 옥텟(octet)을
// 안정적으로, 순서대로, 에러 없이 전송하고, 수신된 패킷을 원래의 메시지로 조립하는 일을 담당한다.
// TCP는 상위 프로토콜을 지원하는 HTTP, FTP, SMTP로, 응용 지원의 텔넷, login, 웹, 전자우편 등으로 활용된다.

// - TCP 특징
// 1) 연결 설정(Connection Setting)
// TCP는 전화를 거는 것처럼 상대와 연결을 설정하고 통신을 시작한다.
// 이 과정을 3 방향 핸드셰이크 메커니즘(3-way Handshake)라고 하고 절차는 아래와 같다.
// - 상대에게 통신을 하고 싶다는 메시지를 보낸다.(SYN)
// - 상대는 그 메시지에 대한 응답 + 나도 통신 준비가 되었다는 메시지를 보낸다.(SYN-ACK)
// - 2번에서 받은 메시지에 응답을 보낸다.(ACK)
// 이와 같은 과정을 통해 나와 상대가 통신준비를 마쳤고, 현재 통신이 연결되어 있음을 보장하게 된다.
// 기존의 회선교환 방식의 개념과 유사하지만 단순히 서로 연결되어 있다는 것만 보장한다.

// 2) 신뢰성 보장과 흐름 제어(Flow Control)
// 연결설정을 통해 통신준비를 마치면 이제 서로 데이터를 주고받을 수 있다.
// 다만 네트워크를 통해서 한 번에 보낼 수 있는 데이터의 양은 제한이 되어 있으므로 분할해서 보내야 된다.
// 분할된 데이터에는 고유번호가 부여되는데 이는 책의 쪽 번호와 같다고 생각하면 된다.
// 이를 바탕으로 보내는 사람은 현재 몇 쪽을 보낸 것인지 상대에게 알려줄 수 있고,
// 받는 사람은 다음에 받을 자료가 몇 쪽인지를 알고 보내는 사람에게 요청할 수 있게 된다.
// 이를 통해 데이터가 제대로 전달됐는지도 알 수 있다.
// 예를 들어 31쪽을 받을 차례인데 31쪽이 안 오고 다른 데이터가 도착한다면 보내줄 때까지 "31쪽을 보내주세요" 요청하도록 TCP가 설계되어 있다.
// 그러면 보내는 사람은 상대가 요청한 31쪽을 보내주게 된다.
// 더불어 47쪽을 보낼 때 알람을 설정하게 되어있는데, 만약 이 알람이 울릴 때까지 받는 사람이 48쪽을 달라고 하지 않으면 역시 데이터가 누락된 것으로 추측할 수 있다.
// 이를 근거로 보내는 사람은 47쪽을 다시 전송할 수 있다.
// 여기까지 언급된 것만 보면 컴퓨터끼리 통신을 할 때 마치 데이터 하나씩만 전달하는 것처럼 보일 수 있다.
// 물론 그렇게 통신한다고 해서 문제가 되는 것은 아니나 당연히 상대가 많이 받을 수 있다면 많이 보내주는 것이 효율적이다.
// 하지만 무턱대고 보낼 수 있는 것도 아니다.
// 상대가 5쪽만 받을 수 있는데 보내는 쪽에서 닥치고 10쪽씩 보내버리면 어차피 5쪽은 못 받고 누락되는 것은 마찬가지이다.
// 따라서 받는 쪽에서 "나 32쪽 받아야 됨. 근데 나 지금 6쪽만큼 받을 수 있음"이라 알려주면 보내는 쪽에서 32쪽에서 37쪽까지 자료를 보내주는 방식으로 동작한다.
// 이를 위한 TCP의 헤더파일을 살펴보면 목적지주소, 확인응답, 오류검출및복원, 실제데이터 등이 포함되는데 UDP와 구분되는 것이 확인응답 파일이다.
// 이것으로 송수신 시 계속 확인응답을 보내어 잘 갔는지, 잘 왔는지 확인을 하여 데이터 신뢰도가 높다.
// 하지만 데이터 용량이 증가하여 수신속도가 떨어진다는 단점이 따라오게 된다(단점보다 장점이 훨씬 크기 때문에 단점은 무시됨).

// 3) 혼잡 제어(Congestion Control)
// 혼잡 제어는 사실 초기 TCP에서는 없던 요소이다.
// 한정된 네트워크 대역폭에서 소수의 사람들이 쓸 때는 몰랐는데 사용자가 점점 늘어나다보니 네트워크 회선이 그 부하를 감당하지 못하고 사망하는 것이 원인이었다.
// 여기서 말하는 사망이란, 송신해야 할 책의 낱장이 중간에 있는 네트워크 기기(라우터 등)에 무한히 몰리게 되는 상황을 말한다.
// 즉, 중간 네트워크 기기가 송신하는 낱장의 속도가 그 기기가 수신하는 속도보다 느리게 되면 이러한 상황이 발생한다.
// 독이 깨져있어서 물이 새는데 물이 새는 속도보다 더 빨리 물을 채운다면 독이 넘치게 할 수 있는 것과 같다.
// 이 상황에서 기존 TCP는 위에서 언급했던 방식대로 동작한다고 생각해보자. 그러면 다음과 같은 일들이 발생한다.
// - 송신자A: '이상하네, 벌써 47쪽을 보낸 지 한참 됐는데 왜 받았다는 연락이 안 올까. 한 번 더 보내야겠다!'
// - 송신자B: '이상하네, 벌써 47쪽을 보낸 지 한참 됐는데 왜 받았다는 연락이 안 올까. 한 번 더 보내야겠다!'
// - 송신자C: '이상하네, 벌써 47쪽을 보낸 지 한참 됐는데 왜 받았다는 연락이 안 올까. 한 번 더 보내야겠다!'
// 여기서 A, B, C는 라우터로 송신하는, 독에 물을 붓는 사람들이다.
// 이미 라우터에는 아직 라우터가 미처 다 송신하지 못한 A, B, C의 낱장들이 남아 있다.
// 그런데 A, B, C가 각각 낱장을 또 보낸다. 이것은 두 가지 문제가 있다.
// - 문제점 1)
// 라우터의 저장에도 한계 용량이 있다.
// 독의 크기가 유한하기 때문에 물을 너무 많이 부으면 넘친다.
// 그 넘친 물은 다시 독으로 들어오지 않듯, 그렇게 라우터 내의 저장 공간에 저장되지 못한 낱장들은 손실된다.
//- 문제점 2)
//흐름 제어의 예시에서 보듯, 47쪽을 보냈는데 답신이 없으면 또 47쪽을 보낸다.
// 만약 라우터가 무한한 저장공간을 가진다는 비현실적인 가정을 하더라도,
// 결국 라우터에 쌓여가는 낱장들 때문에 48쪽을 보낼 때까지 47쪽을 비정상적으로 많이 보내야 한다.이는 비효율적이다.
// 심지어 그러한 가정도 없다면, 보내지는 낱장들은 그저 종이의 낭비이다.
// 전문용어를 쓰자면, 버려지는 패킷을 위해 전력을 사용했으니, 그 전력이 낭비라는 것이다.
// 이러한 문제로 말미암아, 1980년대에 이를 제어하기 위한 방법이 추가됐다.
// 단순한 예로 통신을 시작할 때 일단 보내는 쪽에서 30~35쪽까지 자료를 보내본다.
// 그래서 상대가 잘 받았으면 이후 보내는 양을 조금씩 늘려보는 방식을 취한다.
// 그러다가 상대가 데이터를 제대로 받지 못한 것이 확인되면 그 즉시 보내는 양을 확 줄인다.
// 그리고 다시 슬금슬금 보내는 양을 늘렸다가 또 못 받았으면 줄여버리는 형태로 보내는 양을 조절하게 된다.
// 이 방법은 버스트(burst)를 줄이기 위한 것이다.
// 깨진 독에 어떻게 물이 차오르기 시작하는지를 생각해보면 어렵지 않다.
// 어느 순간에 빠지는 속도보다 들어오는 속도가 커지는 순간이다. 이것을 버스트라고 부른다.
// 요점은 버스트가 나지 않으면 물이 차오르기 시작할 일도 없다는 것이고,
// 버스트가 발생해서 물이 차오르기 시작했다면 일단 물이 다 빠진 다음에 물을 부으면 되겠다는 생각이다.
// 이를 네트워크 환경에 맞추어 해석하면, 처음에 버스트가 생기지 않을 적절한 양을 보내고,
// 버스트가 일어나 라우터에 낱장들이 쌓이기 시작하는 것이 의심된다면 일단 라우터에서 그 낱장들이 빠지는 것을 기다린다는 방법이 되는것이다.
// 위 방법을 통해 TCP로 통신하는 모든 사용자들이 네트워크 상황에 따라 속도를 조절할 수 있게 되었으며,
// 많은 사용자들이 동시에 통신을 시도하면 속도에서 손해를 보게되지만 죽지는 않게 만들었다.
// 이론적으로 100 Mbps 회선에서 5명의 사람이 동시에 TCP로 통신을 시도하면 초반에는 서로 차이가 있지만,
// 궁극적으로는 100 Mbps 회선을 각각 20 Mbps씩 공평하게 나눠가지는 효과를 얻게 된다.

// 4) 연결지향적(Connection Oriented)
// 같은 전송계층의 UDP가 비연결성(connectionless)인 것과는 달리, TCP는 연결지향적이다.
// 이 경우, 느슨한 연결(loosely connected)을 갖으므로 강한 연결을 의미하는 가상회선이라는 표현 보다는 오히려 연결지향적이라고 표현한다.
// 연결 관리를 위한 연결설정 및 연결해제가 필요하다. 양단간 애플리케이션 및 프로세스는 TCP가 제공하는 연결성 회선을 통하여 서로 통신한다.

// 5) TCP 연결의 식별, 다중화, 포트번호
// - TCP 연결(회선)의 식별 : 소켓(양단 IP주소 및 포트번호 쌍)으로 회선을 식별한다. 2개의 IP 주소 및 2개의 포트 번호에 의한 4개가 하나의 연결을 식별한다.
// - 여러 응용 간 다중화 가능 : 단일 연결뿐만아니라 다수 연결의 동시적 처리도 가능하다.
// - 애플리케이션과의 연결점 식별 : TCP는 포트 번호에 의해 애플리케이션과의 연결점을 식별한다.

// 6) 전이중 전송방식, 양방향성(Full-Duplex)
// 종단간 양 프로세스가 서로 동시에 세그먼트를 전달할 수 있다.
// 양방향 각각에 대해 `송수신 버퍼` 및 `데이터흐름용 순서번호`를 유지한다.

// 7) 멀티캐스트 불가능
// 단대단 전송 방식(1:1) 즉, 유니캐스트성이다.
// 단일 송신자와 단일 수신자 간에 단일 경로 연결이 설정된다.

// 8) 바이트스트림(Byte Stream)
// 상위 응용과는 바이트 스트림으로 주고받는다. 논리적 의미를 갖는 단위인 메세지 스트림이 아니다.
// 각 데이터 간의 구분을 의미적으로 구분하지 않고, 단순히 바이트들의 연속적인 흐름으로 보고, 이들을 묶어 세그먼트화하여 전송한다.
// 상위 응용 개발자들이 흐름제어,회선관리,전송단위 등을 신경쓰지 않도록 한다.

// 9) 세그먼트화 처리
// 데이터를 패키징 처리한다. 바이트들을 모아서 세그먼트화하고 이에 TCP 헤더를 붙이고, 이들을 순서제어한다.
// TCP에서 IP로 전달되는 정보 단위(통상, 수 백 바이트 정도) 양 끝단의 TCP 모듈간에 서로 교환되는 데이터 단위를 TCP 세그먼트라고한다.

// 10) 비 실시간적 응용
// TCP는 데이터의 전달에 대한 보장을 하지만, 전달에 따른 지연에는 취약하므로 실시간적 응용에는 통상 UDP를 사용한다.

// (2) IP(Internet Protocol)
// IP는 각 패킷의 주소 부분을 처리해 패킷들이 목적지에 정확하게 도달하도록 하는 일을 담당한다.
// IP의 특징은 신뢰성(에러제어) 및 흐름제어 기능이 전혀 없다는 것이다.
// 신뢰성을 확보하려면 IP 계층 위의 TCP와 같은 상위 트랜스포트 계층에 의존해야 한다.
// 비연결성 데이터그램 방식을 채택하고 있으며 패킷의 완전한 전달(소실,중복,지연,순서바뀜 등이 없게하는 것)을 보장하지 않는다.
// IP 헤더 내 수신 및 발신 주소를 포함하고, IP 헤더 내 바이트 전달 순서는 최상위 바이트(MSB)를 먼저 보낸다는 것도 IP의 특징이다.
// 경우에 따라 단편화가 필요하며 모든 상위 계층 프로토콜(TCP,UDP,ICMP,IGMP 등)이 IP 데이터그램에 실려서 전송된다.

// - TCP/IP 계층의 장단점
// (1) 장점
// TCP/IP는 통합 주소지정 체계를 가진다.
// 소형과 대형 네트워크 모두에서 사용할 수 있는 장비 식별·주소 지정 체계를 가진다.
// 따라서 점점 커지는 네트워크에 적절하며, 유일한 주소를 보장하기 위해 주소체계를 중앙에서 관리한다.
// 라우팅에 용이하다는 것도 TCP/IP의 특징이다.
// 장비보다는 네트워크를 연결하는데 초점이 맞춰져있고, 한 네트워크에서 다른 네트워크로 한 단계씩 데이터를 전달하며,
// 서로 다른 네트워크에 있는 장비 간에 데이터 교환이 가능하다.
// 또한 TCP/IP는 하부 네트워크에 독립적이기 때문에 근거리 네트워크(LAN), 무선(WLAN), 원거리 네트워크(WAN) 같은 모든 하위 계층 네트워크에서 운영이 가능하다.
// 표준과 개발 절차가 공개 되어있어, 표준이 공개되어 있으며 RFC 절차에 따라 누구나 참여 가능하다.
// (2) 단점
// 응용 프로그램 계층 프로토콜인 HTTP(Hypertext Transfer Protocol)는 웹(World Wide Web)의 데이터 전송을위한 기초이지만,
// HTTP는 다양한 보안 위험을 야기하며 침투 및 도용에 취약하다.
// 반면 전송 계층 프로토콜인 TCP는 3 방향 핸드 셰이크 메커니즘, 승인 메커니즘 및 혼잡 제어 메커니즘은 네트워크가 불안정 할 때 대역폭과 시간 낭비를 초래한다.
// 또한 인터넷 레이어 프로토콜인 IP 주소는 종종 실제 주소와 연결된다.
// 사회 공학 기술을 사용하여 해커는 주소를 개인에게 연결하고 개인을 프로파일링하며 사기 행위를 저지를 수 있다.
// 플랫폼은 또한 주요 식별자 중 하나로 IP 주소를 사용하므로 관련 광고를 제공하기 위해 IP 탐색을 추적한다.
// 데이터 링크 계층 프로토콜로서의 이더넷의 단점으로는 CSMA·CD를 사용하는 버스 토폴로지 구조가 대량 충돌 발생시 정체를 일으킬 수 있다는 것이다.
// 만약 중앙 노드가 실패하면 전체 네트워크를 사용할 수 없다.
// 네트워크에 변동이 발생하면 TCP/IP는 대역폭 사용량을 제대로 관리 할 수없고 전송 효율을 빠르게 저하시킬 수 없으며
// 블록체인과 같은 대규모 정보 방송 네트워크를 완벽하게 지원할 수 없어 최신 블록과 동기화하여 이미 채굴된 블록의 시간과 리소스를 낭비한다.
// 또한 TCP/IP 보안 구성 요소에 필요한 배포 및 학습 비용으로 인해 부적절한 배포로 인한 잠재적 취약성이 남아있을 수 있다.
// 더불어 검증, 보안, 데이터 저장을 위해 블록체인에 의존하는 통신 등 모든 블록체인 관련 통신은 TCP/IP를 통해 동일한 문제를 겪게 된다.

// - TCP/IP 4계층
// (1) 4계층 : 응용 계층
// OSI 7 계층에서 세션계층, 프레젠테이션계층, 애플리케이션 계층에 해당한다(5, 6, 7계층).
// 응용프로그램들이 네트워크서비스, 메일서비스, 웹서비스 등을 할 수 있도록 표준적인 인터페이스를 제공한다.
// TCP/IP 기반의 응용 프로그램을 구분할 때 사용한다.
// 프로토콜 : HTTP, FTP, Telnet(텔넷), DNS, SMTP
// (2) 3계층 : 전송 계층
// OSI 7 계층에서 전송 계층(4 계층)에 해당한다.
// 네트워크 양단의 송수신 호스트 사이에서 신뢰성 있는 전송기능을 제공하고, 시스템의 논리주소와 포트를 가지고 있어서 각 상위 계층의 프로세스를 연결해서 통신한다.
// 정확한 패킷의 전송을 보장하는 TCP와 정확한 전송을 보장하지 않는 UDP 프로토콜을 이용하며,
// 데이터의 정확한 전송보다 빠른 속도의 전송이 필요한 멀티미디어 통신에서 UDP를 사용하면 TCP보다 유용하다.
// 통신 노드 간의 연결을 제어하고, 자료의 송수신을 담당한다.
// 프로토콜 : TCP, UDP
// (3) 2계층 : 인터넷 계층
// OSI 7 계층의 네트워크 계층(3 계층)에 해당한다.
// 인터넷 계층의 주요 기능은 상위 트랜스포트 계층으로부터 받은 데이터에 IP패킷 헤더를 붙여 IP패킷을 만들고 이를 전송하는 것이다.
// 통신 노드 간의 IP 패킷을 전송하는 기능 및 라우팅 기능을 담당한다.
// 프로토콜 : IP, ARP, RARP, ICMP, OSPF
// (4) 1계층 : 네트워크 접근 계층(network access layer)
// OSI 7 계층에서 물리계층과 데이터링크 계층(2 계층)에 해당한다.
// OS의 네트워크 카드와 디바이스 드라이버 등과 같이 하드웨어적인 요소와 관련되는 모든 것을 지원하는 계층이다.
// 송신측 컴퓨터의 경우 상위 계층으로부터 전달받은 패킷에 물리적인 주소은 MAC 주소 정보를 가지고 있는 헤더를 추가하여 프레임을 만들고,
// 프레임을 하위계층인 물리 계층으로 전달한다.
// 수신측 컴퓨터의 경우 데이터 링크 계층에서 추가된 헤더를 제거하여 상위 계층인 네트워크 계층으로 전달한다.
// CSMA/CD, MAC, LAN, X25, 패킷망, 위성통신, 다이얼 모뎀 등 전송에 사용된다.
// 프로토콜 : 이더넷, 토큰링, PPP

// - 프로토콜 종류
// ) IP(Internet Protocol)
// Internet-Protocol.js 참고

// ) RP(Routing Protocol)
// Routing-Protocol.js 참고

// ) UDP(User Datagram Protocol)
// 비연결형 및 비신뢰성 전송 서비스를 제공한다.
// 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.
// 수신된 데이터의 순서 재조정 기능을 지원하지 않는다.
// 복구 기능을 제공하지 않는다.
// 단순한 헤더 구조로 오버헤드가 적다.
// TCP와 같이 트랜스포트 계층에 존재한다.

// ) SNMP(Simple Network Management Protocol)

// ) TCP(Transport Control Protocol)

// ) ARP(Address Resolution Protocol)
// IP 네트워크 상에서 IP 주소를 MAC 주소로 변환하는 프로토콜.

// ) ICMP(Internet Control Message Protocol)
// TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜.

// ) PPP(Point-to-Point Protocol)
// 네트워크 분야에서 두 통신 노드 간의 직접적인 연결을 위해 일반적으로 사용되는 데이터 링크 프로토콜이다.
// 점대점 프로토콜은 인증, 암호화를 통한 전송 및 데이터 압축 기능을 제공한다.

// ) Kerberos
// "티켓"(ticket)을 기반으로 동작하는 컴퓨터 네트워크 인증 암호화 프로토콜.
// 비보안 네트워크에서 통신하는 노드가 보안 방식으로 다른 노드에 대해 식별할 수 있게 허용한다.
