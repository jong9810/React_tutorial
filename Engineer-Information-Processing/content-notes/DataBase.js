// - 데이터베이스(DataBase)
//

// - 데이터베이스 설계
// 1) 요구사항 분석
// 사용자의 요구사항을 수집, 분석하여 개발할 데이터베이스의 용도를 파악한다.
// 업무에 필요한 데이터, 데이터를 이용한 처리 방향 등을 고려한다.
// 결과물 : 요구사항 명세서
// 2) 개념적 설계
// DBMS에 독립적인 개념적 스키마 설계
// 요구사항 명세서를 개념적 구조로 표현한다.
// 결과물 : E-R 다이어그램(Entity-Relation Diagram)
// - E-R 다이어그램(Entity-Relation Diagram, ERD)
// 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델
// 개념적 모델링의 대표적인 도구
// 1대 1, 1대 다, 다대 다를 표현할 수 있고, ERD 표준기호와 새발 표기법을 사용하여 표기한다.
// 3) 논리적 설계
// DBMS에 적합한 논리적 구조 설계
// 결과물 : 논리적 스키마(릴레이션 스키마)
// 4) 물리적 설계
// DBMS로 구현 가능한 물리적 구조 설계
// 결과물 : 물리적 스키마
// 5) 구현
// 데이터베이스 생성

// -(데이터베이스에서) 뷰(View)
// 1) 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
// 2) 뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다.
// 3) 뷰는 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.
// 4) 뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다.
// - 뷰(View)의 특징
// 1) 뷰는 기본테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다.
// 2) 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다.
// 3) 데이터의 논리적 독립성을 제공할 수 있다.
// 4) 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
// 5) 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.
// 6) 기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야지만 삽입, 삭제, 갱신, 연산이 가능하다.
// 7) 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
// 8) 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.
// - 뷰(View) 사용시 장점
// 1) 논리적 데이터 독립성을 제공한다.
// 2) 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해 준다.
// 3) 사용자의 데이터관리를 간단하게 해준다.
// 4) 접근 제어를 통한 자동 보안이 제공된다.
// - 뷰(View) 사용시 단점
// 1) 독립적인 인덱스를 가질 수 없다.
// 2) ALTER VIEW문을 사용할 수 없다. 즉 뷰의 정의를 변경할 수 없다.
// 3) 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

// - 데이터 모델 정의
// 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화한 체계적인 개념적 모형을 말한다.
// 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 사용되는 지능적인 도구
// - 데이터 모델의 구성 요소
// 1) 개체(Entity) : 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
// 2) 속성(Attribute) : 가장 작은 논리적 단위, 데이터 항목, 데이터 필드
// 3) 관계(Relationship) : 개체 간의 관계, 속성 간의 논리적인 연결
// - 데이터 모델 종류
// 1) 개념적 데이터 모델
// 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정.
// 대표적인 개념적 데이터 모델로는 E-R 모델이 있다.
// 2) 논리적 데이터 모델
// 개념적 모델링 과정에서 얻은 구조를 컴퓨터가 이해하고 처리할 수 있게 변환하는 과정.
// '정규화' 작업이 논리적 데이터 모델링에 해당한다.
// 3) 물리적 데이터 모델
// 실질적 데이터 구조 설계로, 테이블 정의서, 명세서 등이 있다.
// - 데이터 모델에 표시할 요소
// 1) 구조(Structure) : 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현
// 2) 연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
// 3) 제약조건(Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약조건

// - 데이터 무결성(Data Integrity) 제약조건(Constraint) 종류
// 1) 개체 무결성(Entity Integrity)
// 기본키 제약이라고도 하며, 테이블은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 하는 조건이다.
// 기본키에는 NULL 값이 올 수 없다.
// 기본키는 테이블 내에 오직 하나의 값만 존재해야 한다(하나의 테이블 내에 동일한 기본키를 가진 레코드는 존재할 수 없음).
// 2) 참조 무결성(Referential Integrity)
// 외래키 제약이라고도 하며, 테이블 간의 참조 관계를 선언하는 제약조건
// 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다.
// 외래키 속성은 참조할 수 없는 값을 지닐 수 없다(외래키 속성값이 상위 테이블의 인스턴스에 반드시 존재하거나 NULL이어야 함).
// 3) 도메인 무결성(Domain Integrity)
// 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로, 필드의 타입, NULL 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 조건
// 예를 들어, 주민등록번호 필드에 문자가 입력되는 경우에는 도메인 무결성이 깨졌다고 볼 수 있다.
// 속성들의 값은 정의된 도메인에 속한 값이어야 한다.
// 4) 고유 무결성
// 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들이 서로 달라야 하는 조건
// 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 한다.
// 5) NULL 무결성
// 테이블의 특정 속성 값이 NULL 값이 될 수 없게 하는 조건
// 릴레이션의 특정 속성 값은 NULL 값이 될 수 없다.
// 6) 키 무결성
// 하나의 테이블에 적어도 하나의 키가 존재해야 하는 조건
// 각 릴레이션은 최소한 한 개 이상의 키가 존재해야 한다.
// - 무결성 제약조건 장점
// 스키마를 정의할 때 일관성 조건을 오직 한 번만 명시하고,
// 데이터베이스가 갱신될 때 DBMS가 자동으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없다.
// - 무결성 제약조건 단점
// 무결성 제약조건을 반복해서 구현해야 하므로 프로그래밍 작업이 훨씬 복잡해지고, 무결성 제약조건들 간에 서로 충돌이 발생할 수 있다.
