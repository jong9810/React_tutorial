// - 스케줄링(Scheduling) : 일반적으로 처리할 일들의 진행순서를 정하는 일을 의미한다.
// 1) 프로세스 스케줄링 : CPU를 사용하려고 하는 프로세스들 사이의 우선 순위를 관리하는 일
// 2) 디스크 스케줄링 : 디스크를 사용하려고 하는 프로세서들 사이의 우선 순위를 관리하는 일

// - 호위 효과
// 앞선 프로세스가 실행시간이 길다면 실행시간이 짧은 프로세스들이 실행되지 못해 마치 부하처럼 뒤따라서 기다리고 있다는 것을 가리키는 효과이다.
// 만약 사람 3명이 화장실에 들어가려고 하는데 2명은 소변을, 1명은 대변을 누기를 희망한다고 가정해보자.
// 만약 대변을 누고싶은 사람이 가장 먼저 들어가면 2명의 사람은 매우 오랫동안 소변을 참아야한다. 우리는 이 것이 매우 비효율적이라는 것을 알 수 있다.

// - PCB(Process Control Block)
// 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영 체제 커널의 자료 구조

// - 레지스터(Register)
// 프로세서에 위치한 고속 메모리로 극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역
// CPU(Central Processing Unit)가 요청을 처리하는 데에 필요한 데이터를 일시적으로 저장하는 기억장치이다.
// 실제로 컴퓨터에서 데이터를 영구적으로 저장하기 위해서는 하드디스크를 이용해야 하고,
// 임시적으로 저장하는 장소를 메모리(RAM)이라고 알고 있을 것이다.
// 하지만 메모리로 연산의 결과를 보내고 영구적으로 저장할 데이터를 하드디스크에 저장해야 하는 등의 명령을 처리하기 위해서는
// 이들에 대한 주소와 명령의 종류를 저장할 수 있는 기억 공간이 하나 더 필요하다.
// 그리고 이 공간은 무리없이 명령을 수행하기 위해 메모리보다 빨라야 한다.
// 바로 이런 역할들을 하는 것이 CPU 옆에 붙어있는 레지스터이다.
// 레지스터는 공간은 작지만 CPU와 직접 연결되어 있으므로 연산 속도가 메모리보다 실제 수십 배에서 수백 배까지 빠르다.
// 그리고 CPU는 자체적으로 데이터를 저장할 방법이 없기 때문에 메모리로 직접 데이터를 전송할 수 없다.
// 때문에 연산을 위해서는 반드시 레지스터를 거쳐야 하며, 이를 위해서 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있다.

// - 하드와이어드 : 논리 회로를 이용한 하드웨어

// - CISC/RISC 개념
// CPU(중앙처리장치)를 설계하는 방식이다.
// CPU가 동작하려면 프로그램이 있어야 하고 명령어를 주입해서 설계한다.
// 1) 명령어가 H/W적인 방식을 RISC라고 한다.
// 2) 명령어가 S/W적인 방식을 CISC라고 한다.

// - CISC(Complex Instruction Set Computer)
// 복잡하고 많은 종류의 명령어와 주소 지정 모드를 사용한다.
// 가변 길이 명령어 형식이다.
// 100개 ~ 250개 정도의 많은 명령어를 가지고 있어 설계가 어렵다.
// 마이크로 프로그래밍(S/W) 제어 방식이다.
// 명령어가 S/W적이므로 호환성이 좋다.
// 명령어를 해석한 후에 명령어를 실행한다.
// 컴파일 과정이 쉽고, 호환성이 좋다는 장점이 있지만 속도가 느리다.
// intel 사의 CPU에 주로 사용되었다.

// - RISC(Reduced Instruction Set Computer)
// 갼단하고 적은 종류의 명령어와 주소 지정 모드를 사용한다.
// 고정 길이 명령어 형식이다.
// CISC에 비해 명령어 수가 적다.
// 하드와이어드(논리 회로를 이용한 하드웨어)적 제어 방식이다.
// 효율적인 파이프라이닝 구조를 사용한다.
// 명령어가 하드웨어적이므로 호환성이 낮다.
// 명령어의 길이가 미리 정해져 있으므로 해석 속도가 빠르다.
// 작고 빠른 명령어들을 사용하기 위해 많은 수의 범용 레지스터가 사용되며, 처리속도가 빠르고 하드웨어 구조가 간단하다.
// 효율성이 떨어지고 전력 소모가 적으며, 처리 비트 단위가 변하거나 프로세서 구조가 조금만 바뀌어도 하위 프로세서와의 호환성이 떨어진다.
// 고성능의 워크스테이션이나 그래픽용 컴퓨터에 주로 사용된다.

// - 문맥교환(Context Switching)
// 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해,
// 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적제하는 작업을 말한다.
// 프로세스의 문맥(Context)은 PCB(Process Control Block)에 저장된다.
// 인터럽트(Interrupt)가 발생하면 시스템은 현재 수행 중인 프로세스의 문맥을 저장하고, 이후 해당 프로세스가 재개될 때 복원한다.
// - 문맥교환 과정
// 1) CPU 코어를 다른 프로세스로 교환해야할 일이 생김.
// 2) 현재 프로세스의 상태를 저장
// 3) 다른 프로세스의 상태를 복원
// - 문맥교환이 필요한 시점
// 1) 멀티태스킹
// 2) 인터럽트 핸들링
// 3) 사용자 모드와 커널 모드 간의 전환

// - 오버헤드(Overhead)
// 어떤 처리를 하기 위해 들어가는 간접적인 처리시간, 메모리 등을 말한다.
// 예를 들어, A라는 처리를 단순하게 실행하는 데에 10초가 걸리는데, 안정성을 고려하여 부가적인 B라는 처리를 추가한 결과 처리시간이 15초가 걸렸다면,
// 오버헤드는 5초가 된다.
// 또한 이 처리 B를 개선해 B'라는 처리를 한 결과, 처리시간이 12초가 되었다면, 이 경우 오버헤드가 3초 단축되었다고 표현한다.

// - 문맥교환과 오버헤드
// 문맥을 교환하는 동안에는 유용한 작업을 수행할 수 없기 때문에, 문맥교환 시간은 일종의 오버헤드라고 할 수 있다.
// 복잡 명령어 집합 컴퓨터(Complex Instruction Set Computer, CISC)와 축소 명령어 집합 컴퓨터(Reduced Instruction Set Computer, RISC)는 각각 장단점이 있는데,
// 문맥교환 측면에서 보면 RISC가 CISC보다 레지스터의 용량이 상대적으로 더 크기 때문에 좀 더 큰 오버헤드가 발생한다.

// - 시분할 시스템(Time-sharing System)
// 시분할 시스템은 컴퓨터를 대화식으로 사용하려는 시도에서 탄생하였다.
// 시분할 운영체제는 CPU 스케줄링과 다중 프로그래밍을 이용해서 각 사용자들에게 컴퓨터 자원을 시간적으로 분할하여 사용할 수 있게 해준다.
// 라운드 로빈 스케줄링은 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스들 사이에 우선순위를 두지 않고,
// 순서대로 시간 단위(Time Quantum)로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘이다.

// - 일괄 처리 시스템
// 일괄 처리 시스템은 초기의 컴퓨터 시스템에서 사용된 형태로, 일정량 또는 일정 기간 동안 데이터를 모아서 한꺼번에 처리하는 방식이다.

// - 스케줄링 기법 구분
// 1) 선점 스케줄링 방식
// 하나의 프로세스가 CPU를 할당 받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 기법이다.
// 모든 프로세스에게 CPU 사용시간을 동일하게 부여할 수 있으며, 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하고 긴급한 프로세서를 제어가능하다.
// 2) 비선점 스케줄링 방식
// 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법이다.
// 즉, 한 프로세스가 수행 중이라면 그 프로세스가 종료되기 전까지 CPU는 반드시 그 프로세스만 실행 할 수 있는 스케줄링 기법이다.
// 선점 스케줄링 방식보다 스케줄러 호출 빈도가 낮고 문맥 교환에 의한 오버헤드도 적다.
// 일괄처리 시스템에 적합하고, CPU 사용시간이 긴 하나의 프로세스가 CPU 사용시간이 짧은 여러 프로세스를 오래 대기시킬 수 있으므로
// 처리율이 떨어질 수 있다는 단점이 있다.

// - 스케줄링 기법 종류
// 1) SJF(Shortest Job First) 스케줄링 기법(비선점 방식)
// 평균 대기시간을 최소화하기 위해 프로세스의 실행시간(CPU 점유 시간)이 가장 적은 프로세스를 먼저 실행시키는 기법
// 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 연기 상태에 빠질 수 있다는 단점이 있다.
// 2) FIFO(First In First Out) 스케줄링 방식(비선점 방식)
// 프로세서를 요청하는 순서대로 처리하는 방법(선입선출)
// 스케줄링의 이해와 구현이 단순하다.
// 준비 큐에 있는 모든 프로세서가 결국 실행되므로 기아 없는 공정한 정책이다.
// 프로세서가 지속적으로 유용한 프로세스를 수행하여 처리율이 높다.
// 비선점 방식이므로 대화식 프로세스에는 부적합하다.
// 장기 실행 프로세스가 있으면 뒤에 있는 모든 프로세스를 대기시켜 평균 대기 시간이 길어지며, 최악의 대기 시간이 될 수 있다.
// 긴 프로세스가 실행되는 동안 짧은 프로세스가 긴 대기 시간으로 호위 효과가 발생할 수 있다.
// 3) HRN(Highest Response-ratio Next) 스케줄링 방식(비선점 방식)
// 실행시간이 긴 프로세스에 불리한 SJF기법을 보완하기 위한 것으로, 대기시간과 서비스 실행 시간을 이용하는 방식이다.
// 우선순위( == 시스템 응답시간) = (대기시간 + 서비스 실행 시간) / (서비스 실행 시간)
// 우선순위(시스템 응답시간) 값이 큰 것부터 실행하는 방식이다.
// 이렇게 프로세스가 자원을 기다리고 있는 시간에 비례하여 우선순위를 부여함으로써 무한 연기의 문제를 방지하는 것을 '에이징(Aging) 기법'이라고 한다.
// 4) RR(Round Robin) 스케줄링 방식(선점 방식)
// 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간 단위로 CPU를 할당하는 방식이다.
// 보통 시간 단위는 10ms ~ 100ms 정도이고 시간 단위동안 수행한 프로세스는 준비 큐의 끝으로 밀려나게 된다.
// 문맥 전환의 오버헤드가 큰 반면, 응답시간이 짧아지는 장점이 있어 실시간 시스템에 유리하고, 할당되는 시간이 클 경우 비선점 FIFO 기법과 같아지게 된다.
// 5) 다단계 큐(Multi-level Queue, MQ) 스케줄링 방식(선점 방식)
// 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각기 다른 준비 상태 큐를 사용하는 기법이다.
// 프로세스가 특정 그룹의 준비 상태 큐에 들어갈 경우 다른 준비 상태 큐로 이동할 수 없다.
// 하위 준비 상태 큐에 있는 프로세스를 실행하는 도중이라도 상위 준비 상태 큐에 프로세스가 들어오면 상위 프로세스에게 CPU를 할당해야 한다.
// <예시>
// - level 1, 2, 3 큐가 있을 때, 레벨 1의 큐가 모두 완료되어야만 레벨 2의 큐로 넘어갈 수 있고, 레벨 2의 큐가 모두 완료되어야 그 다음으로 넘어갈 수 있다.
// 6) SRT(Shortest Remaining Time) 스케줄링 방식(선점 방식)
// 비선점 스케줄링인 SJF 기법을 선점 형태로 변형한 기법이다.
// SJF처럼 CPU 점유 시간이 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식으로,
// SJF와 차이점은 선점 방식으로 바뀌어 중요한 프로세스가 있으면 점유 시간이 길어도 먼저 실행시킬 수 있는 권한이 있다는 것이다.
