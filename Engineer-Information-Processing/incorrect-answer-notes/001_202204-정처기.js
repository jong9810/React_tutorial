// 2022년 04월 정보처리기사 필기
//-------------------------------------------------------------------------------------------------------------------------------------------------

// 소프트웨어 설계

// 1. UML 다이어그램 중 순차 다이어그램
// (1) 객체 간의 동적 상호작용을 시간 개념을 중심으로 모델링하는 것이다.
// (X) 주로 시스템의 정적(->동적) 측면을 모델링하기 위해 사용한다.
// (3) 일반적으로 다이어그램의 수직 방향이 시간의 흐름을 나타낸다.
// (4) 회귀 메시지(Self-message), 제어 블록(Statement-block) 등으로 구성된다.
// <해설>
// - 순차 다이어그램은 행위 다이어그램이므로 동적이고, 순차적인 표현을 위한 다이어그램이다.

// 2. 메시지 지향 미들웨어(Message-Oriented Middleware, MOM)
// (X) 느리고 안정적인 응답보다는 즉각적인 응답이 필요한 온라인 업무에 적합하다.
// (2) 독립적인 애플리케이션을 하나의 통합된 시스템으로 묶기 위한 역할을 한다.
// (3) 송신측과 수신측의 연결 시 메시지 큐를 활용하는 방법이 있다.
// (4) 상이한 애프리케이션 간 통신을 비동기 방식으로 지원한다.
// <해설>
// - Middleware.js 참고

// 3. 익스트림 프로그래밍
// (X) 대표적인 구조적 방법론 중 하나이다.
// (2) 소규모 개발 조직이 불확실하고 변경이 많은 요구를 접하였을 때 적절한 방법이다.
// (3) 익스트림 프로그래밍을 구동시키는 원리는 상식적인 원리와 경험을 최대한 끌어올리는 것이다.
// (4) 구체적인 실천 방법을 정의하고 있으며, 개발 문서보다는 소스코드에 중점을 둔다.
// <해설>
// - 구조적 방법론이 아니라 애자일 방법론 중 하나이다.
// <용어 정리>
// - 애자일(Agile) : 날렵한, 민첩한, 기민한이라는 뜻으로, 소프트웨어 개발 방법론 중 하나인 애자일 프로세스에서 처음 사용되었다.

// 4. 유스 케이스(Use case)의 구성요소 간의 관계에 포함되지 않는 것은?
// (1) 연관
// (2) 확장
// (X) 구체화
// (4) 일반화
// <해설>
// - UML-Diagram.js 참고

// 5. 요구사항 분석에서 비기능적(Nonfunctional) 요구
// (X) 시스템의 처리량(Throughput), 반응 시간 등의 성능 요구나 품질 요구는 비기능적 요구에 해당하지 않는다.
// (2) '차량 대여 시스템이 제공하는 모든 화면이 3초 이내에 사용자에게 보여야 한다.'는 비기능적 요구이다.
// (X) 시스템 구축과 관련된 안전, 보안에 대한 요구사항들은 비기능적 요구에 해당하지 않는다.
// (X) '금융 시스템은 조회, 인출, 입금, 송금의 기능이 있어야 한다.'는 비기능적 요구이다.
// <해설>
// - 기능적 요구사항
// 시스템이 실제로 어떻게 동작하는지에 관점을 둔 요구사항
// - 비기능적 요구사항
// 시스템 구축에 대한 성능, 보안, 품질, 안정성 등으로 실제 수행에 보조적인 요구사항

// 6. 정보공학 방법론에서 데이터베이스 설계의 표현으로 사용하는 모델링 언어
// (X) Package Diagram
// (X) State Transition Diagram
// (X) Deployment Diagram
// (4) Entity-Relationship Diagram
// <해설>
// - (1), (2), (3) : UML 다이어그램
// - (4) : 정보공학 방법론

// 7. 미들웨어(Middleware)
// (1) 여러 운영체제에서 응용 프로그램들 사이에 위치한 소프트웨어이다,
// (X) 미들웨어의 서비스 이용을 위해 사용자가 정보 교환 방법 등의 내부 동작을 쉽게 확인할 수 있어야 한다.
// (3) 소프트웨어 컴포넌트를 연결하기 위한 준비된 인프라 구조를 제공한다.
// (4) 여러 컴포넌트를 1대 1, 1대 다, 다대 다 등 여러가지 형태로 연결이 가능하다.
// <해설>
// - Middleware.js 참고

// 8. UI(User Interface) 설계 지침
// (1) 이해하기 편하고 쉽게 사용할 수 있는 환경을 제공해야 한다.
// (2) 주요 기능을 메인 화면에 노출하여 조작이 쉽도록 하여야 한다.
// (X) 치명적인 오류에 대한 부정적인 사항은 사용자가 인지할 수 없도록 한다.
// (4) 사용자의 직무, 연령, 성별 등 다양한 계층을 수용하여야 한다.
// <해설>
// - User-Interface.js 참고

// 9. 객체지향 개념에서 다형성(Polymorphism)
// (1) 다형성은 현재 코드를 변경하지 않고 새로운 클래스를 쉽게 추가할 수 있게 한다.
// (2) 다형성이란 여러 가지 형태를 가지고 있다는 의미로, 여러 형태를 받아들일 수 있는 특징을 말한다.
// (3) 메소드 오버라이딩(Overriding)은 상위 클래스에서 정의한 일반 메소드의 구현을 하위 클래스에서 무시하고 재정의할 수 있다.
// (X) 메소드 오버로딩(Overloading)의 경우 매개 변수 타입은 동일하지만 메소드명을 다르게 함으로써 구현, 구분할 수 있다.
// <해설>
// - Object-Oriented-Programming.js 참고

// 10. 소프트웨어 개발 영역을 결정하는 요소 중 다음 사항과 관계있는 것은?
// - 소프트웨어에 의해 간접적으로 제어되는 장치와 소프트웨어를 실행하는 하드웨어
// - 기존의 소프트웨어와 새로운 소프트웨어를 연결하는 소프트웨어
// - 순서적 연산에 의해 소프트웨어를 실행하는 절차
// (X) 기능(Function)
// (X) 성능(Performance)
// (X) 제약조건(Constraint)
// (4) 인터페이스(Interface)
// <해설>
// - 인터페이스 : 서로 다른 두 시스템이나 소프트웨어 등을 이어주는 부분 또는 접속 장치를 의미

// 11. 객체에 대한 설명
// (1) 객체는 상태, 동작, 고유 식별자를 가진 모든 것이라 할 수 있다.
// (X) 객체는 공통 속성을 공유하는 클래스들의 집합이다.
// (3) 객체는 필요한 자료 구조와 이에 수반되는 함수들을 가진 하나의 독립된 존재이다.
// (4) 객체의 상태는 속성값에 의해 정의된다.
// <해설>
// - 클래스는 공통 속성을 공유하는 객체들의 집합이다.
// - Object-Oriented-Programming.js 참고

// 12. 객체지향 개념
// - 속성과 관련된 연산(Operation)을 클래스 안에 묶어서 하나로 취급하는 것
// (X) Inheritance(상속)
// (X) Class(클래스)
// (3) Encapsulation(캡슐화)
// (X) Association(연관)
// <해설>
// - 클래스 : 하나 이상의 유사한 객체들을 묶는다.
// - 캡슐화 : 서로 관련성이 많은 데이터들과 연산들을 묶는다.
// - Object-Oriented-Programming.js 참고

// 13. 애자일(Agile) 프로세스 모델
// (X) 변화에 대한 대응보다는 자세한 계획을 중심으로 소프트웨어를 개발한다.
// (2) 프로세스와 도구 중심이 아닌 개개인과의 상호소통을 통해 의견을 수렴한다.
// (3) 협상과 계약보다는 고객과의 협력을 중시한다.
// (4) 문서 중심이 아닌, 실행가능한 소프트웨어를 중시한다.
// <해설>
// - Agile-Methodology.js 참고

// 14. 명백한 역할을 가지고 독립적으로 존재할 수 있는 시스템의 부분으로 넓은 의미에서는 재사용되는 모든 단위라고 볼 수 있으며,
//     인터페이스를 통해서만 접근할 수 있는 것은?
// (X) Model
// (X) Sheet
// (3) Component
// (X) Cell
// <해설>
// - 컴포넌트
// 프로그래밍에 있어 재사용이 가능한 각각의 독립된 모듈
// 특정 기능수행을 위해 독립적으로 분리

// 15. GoF(Gang of Four) 디자인 패턴을 생성, 구조, 행동 패턴의 세 그룹으로 분류할 때, 구조 패턴이 아닌 것은?
// (1) Adaptor 패턴
// (2) Bridge 패턴
// (X) Builder 패턴
// (4) Proxy 패턴
// <해설>
// - Design-Pattern.js 참고

// 16. UI와 관련된 기본 개념
// - 시스템의 상태와 사용자의 지시에 대한 효과를 보여주어 사용자가 명령에 대한 진행 상황과 표시된 내용을 해설할 수 있도록 도와주는 것은?
// (1) Feedback
// (X) Posture(자세)
// (X) Module
// (X) Hash
// <해설>
// - User-Interface.js 참고

// 17. UI의 종류로 멀티 터치(Multi-touch), 동작 인식(Gesture Recognition) 등 사용자의 자연스러운 움직임을 인식하여
// 서로 주고받는 정보를 제공하는 사용자 인터페이스를 의미하는 것은?
// (X) GUI(Graphical User Interface)
// (X) OUI(Organic User Interface)
// (3) NUI(Natural User Interface)
// (X) CLI(Command Line Interface)
// <해설>
// - User-Interface.js 참고

// 18. 소프트웨어 모델링
// (X) 모델링 작업의 결과물은 다른 모델링 작업에 영향을 줄 수 없다.
// (2) 구조적 방법론에서는 DFD(Data Flow Diagram), DD(Data Dictionary) 등을 사용하여 요구사항의 결과를 표현한다.
// (3) 객체지향 방법론에서는 UML 표기법을 사용한다.
// (4) 소프트웨어 모델을 사용할 경우 개발될 소프트웨어에 대한 이해도 및 이해 당사자 간의 의사소통 향상에 도움이 된다.
// <해설>
// - (1)의 반례 : 유스케이스 명세로부터 필요한 요소들을 가져와 도메인 모델로 정리할 수 있음.
// <용어 정리>
// - DFD(데이터 흐름도) : 프로세스나 시스템의 정보 흐름을 나타내는 도표.
// - DD(데이터 사전) : 프로그래머의 편의를 위해 데이터 모델 내의 데이터 객체들이나 항목들의 설명을 모아놓은 것.
// - UML 표기법 : 시스템을 모델로 표현해주는 대표적인 모델링 언어.

// 19. 유스 케이스 다이어그램
// (X) 시스템과 상호작용하는 외부 시스템은 액터로 파악해서는 안된다.
// (2) 유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.
// (3) 시스템 액터는 다른 프로젝트에서 이미 개발되어 사용되고 있으며, 본 시스템과 데이터를 주고받는 등 서로 연동되는 시스템을 말한다.
// (4) 액터가 인식할 수 없는 시스템 내부의 기능을 하나의 유스케이스로 파악해서는 안된다.
// <해설>
// - 액터 : 시스템과 상호작용하는 모든 것(사람, 기계, 시스템 등)
// <용어 정리>
// - 유스케이스
// 행위자(actor)가 관심을 가지고 있는 유용한 일을 달성하기 위한 시나리오의 집합을 명시한다.
// 사용자 입장에서 바라본 시스템의 특성을 설명한 구조로서, 행위자, 시간의 흐름, 또는 시스템에 의해 개시되는 시나리오 집합의 형태를 갖추고 있다.

// 20. 소프트웨어 아키텍처 모델 MVC(Model-View-Controller)
// (1) MVC 모델은 사용자 인터페이스를 담당하는 계층의 응집도를 높일 수 있고, 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있다.
// (X) 모델(Model)은 뷰(View)와 제어(Controller) 사이에서 전달자 역할을 하며, 뷰마다 모델 서브 시스템이 각각 하나씩 연결된다.
// (3) 뷰(View)는 모델(Model)에 있는 데이터를 사용자 인터페이스에 보이는 역할을 담당한다.
// (4) 제어(Controller)는 모델(Model)에 명령을 보냄으로써 모델의 상태를 변경할 수 있다.
// <해설>
// - 한 개의 모델에 대해 여러 개의 뷰를 만들 수도 있다.
// - 모델은 서브 시스템의 핵심 기능과 데이터를 보관하며 MVC 패턴에서는 여러 개의 뷰를 만들 수 있으므로
//   한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 어플리케이션에 적합하다.
// <용어 정리>
// - MVC : 사용자 인터페이스, 데이터 및 논리 제어를 구현하는 데 널리 사용되는 소프트웨어 디자인 패턴

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 소프트웨어 개발

// 21. 통합 테스트(Integration Test)
// (1) 시스템을 구성하는 모듈의 인터페이스와 결함을 테스트하는 것이다.
// (2) 하향식 통합 테스트의 경우, 넓이 우선(Breath-First) 방식으로 테스트를 할 모듈을 선택할 수 있다.
// (X) 상향식 통합 테스트의 경우, 시스템 구조도의 최상위에 있는 모듈을 먼저 구현하고 테스트한다.
// (4) 모듈 간의 인터페이스와 시스템의 동작이 정상적으로 잘 되고 있는지를 빨리 파악하고자할 때 상향식보다는 하향식 통합 테스트를 사용하는 것이 좋다.
// <해설>
// - 상향식 통합 테스트(Bottom-Up Integration Test)
// 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합
// 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster) 필요
// - 하향식 통합 테스트(Top-Down Integration Test)
// 상위 모듈에서 하위 모듈 방향으로 통합
// 깊이 우선 통합법, 넓이 우선 통합법 사용
// 초기부터 사용자에게 시스템 구조를 보여줌

// 22. 이진 탐색 방법
// - 이진 탐색 동작 방식
// 1) 배열의 중간 값을 찾음.
// 2) 중간 값과 검색 값을 비교
// 2-1) 중간 값이 검색 값과 같으면 끝
// 2-2) 중간 값이 검색 값보다 작으면 오른쪽 구간을 탐색
// 2-3) 중간 값이 검색 값보다 크면 왼쪽 구간을 탐색
// 3) 값을 찾거나 간격이 비었을 때까지 반복

// 23. 소프트웨어 공학에서 워크스루(Walk-through)
// (1) 사용 사례를 확장하여 명세하거나 설계 다이어그램, 원시 코드, 테스트 케이스 등에 적용할 수 있다.
// (2) 복잡한 알고리즘 또는 반복, 실시간 동작, 병행 처리와 같은 기능이나 동작을 이해하려고 할 때 유용하다.
// (X) 인스펙션(Inspection)과 동일한 의미를 가진다.
// (4) 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행해보는 것이다.
// <해설>
// - 워크스루(Walk-through) : 요구사항 명세서 작성자를 포함하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견.
// - 인스펙션(Inspection) : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견.

// 24. 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동을 뜻하는 것은?
// (X) 복호화
// (2) 형상관리
// (X) 저작권
// (X) 크랙
// <해설>
// - 복호화 : 디코딩, 즉 부호화된 데이터를 부호화되기 전 형태로 바꾸어 사람이 읽을 수 있는 형태로 되돌려 놓은 것
// - 형상관리 : 소프트웨어의 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동
// - 저작권 : 창작물을 만든 이가 자신의 저작물에 대해 가지는 법적 권리
// - 크랙 : 소프트웨어를 수정하여 개발자가 원하지 않는 기능들, 보통은 수정 방식(복사 보호, 소프트웨어 조작 보호)을 비활성화하거나 제거하는 일

// 25. 테스트 케이스
// (X) 테스트의 목표 및 테스트 방법을 결정하기 전에 테스트 케이스를 작성해야 한다.
// (2) 프로그램에 결함이 있더라도 입력에 대해 정상적인 결과를 낼 수 있기 때문에 결함을 검사할 수 있는 테스트 케이스를 찾는 것이 중요하다.
// (3) 개발된 서비스가 정의된 요구 사항을 준수하는지 확인하기 위한 입력 값과 실행 조건, 예상 결과의 집합으로 볼 수 있다.
// (4) 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다.
// <해설>
// - 테스트 케이스(Test Case)
// 구현된 소프트웨어가 사용자의 요구 사항을 정확하게 준수했는지를 확인하기 위해
// 설계된 입력값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서를 의미한다.
// 테스트의 목표 및 테스트 방법을 결정하고 테스트 케이스를 작성해야 한다.
// <용어 정리>
// - 테스트 오라클(Test Oracle) : 테스트 실행 결과의 참/거짓 판별 기준

// 26. 객체지향 개념을 활용한 소프트웨어 구현
// (1) 객체(Object)란 필요한 자료 구조와 수행되는 함수들을 가진 하나의 독립된 존재이다.
// (X) JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 '공개'이다
// (3) 상속(Inheritance)은 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다는 장점이 있다.
// (4) 같은 클래스에 속하는 개개의 객체이자 하나의 클래스에서 생성된 객체를 인스턴스(Instance)라고 한다.
// <해설>
// - JAVA에서 정보은닉(Information Hiding)을 표기할 때 private의 의미는 외부에서 클래스 내부 정보에 접근하지 못하도록 하는 '접근금지'이다.
// <용어 정리>
// - 정보은닉(or 은닉성) : 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해 접근을 허용하는 것으로, 클래스 외부에서 특정 정보에 접근을 막는다는 의미

// 27. DRM(Digital Rights Management)
// (1) 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다.
// (2) 디지털 미디어의 생명 주기 동안 발생하는 사용 권한 관리, 과금, 유통 단계를 관리하는 기술로도 볼 수 있다.
// (3) 클리어링 하우스(Clearing House)는 사용자에게 콘텐츠 라이센스를 발급하고 권한을 부여해주는 시스템을 말한다.
// (X) 원본을 안전하게 유통하기 위한 전자적 보안은 고려하지 않기 때문에 불법 유통과 복제의 방지는 불가능하다.
// <해설>
// - DRM(Digital Rights Management)
// 디지털 콘텐츠의 지적재산권보호, 관리 기능 및 안전한 유통과 배포를 보장하는 솔루션이다.
// 디지털 콘텐츠의 지적재산권을 보호하는 권한통제 기술, 사용권한제어 기술, 패키징 기술, 라이선스 관리를 포함한 유통 체계이다.
// 디지털 콘텐츠와 디바이스의 사용을 제한하기 위해 하드웨어 제조업자, 저작권자, 출판업자 등이 사용할 수 있는 접근 제어 기술을 의미한다.
// <용어 정리>
// - DRM
// 출판자 또는 저작권자가 그들이 배포한 디지털 자료나 하드웨어의 사용을 제어하고 이를 의도한 용도로만 사용하도록 제한하는 데 사용되는 모든 기술들을 지칭하는 용어
// - 클리어링 하우스
// 디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 정산소로서 라이센서(licensor)와 라이센시(licensee)가 아닌 제3의 운영주체가 운영한다.

// 28. 위험 모니터링의 의미
// (X) 위험을 이해하는 것
// (X) 첫 번째 조치로 위험을 피할 수 있도록 하는 것
// (X) 위험 발생 후 즉시 조치하는 것
// (4) 위험 요소 징후들에 대하여 계속적으로 인지하는 것

// 29. 동시에 소스를 수정하는 것을 방지하며 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있는 소프트웨어 버전 관리 도구는?
// (1) RCS(Revision Control System)
// (X) RTS(Reliable Transfer Service)
// (X) RPC(Remote Procedure Call)
// (X) RVS(Relative Version System)
// <해설>
// - RCS(Revision Control System)
// CVS와의 차이점은 소스 파일의 수정을 한 사람만으로 제한한다는 것이다.
// 다수의 사용자가 동시에 파일 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구이다.
// 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적할 수 있다.
// - RPC(Remote Procedure Call)
// 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행할 수 있게 해주는 프로세스 간 통신
// <용어 정리>
// - RTS(Reliable Transfer Service, 안정적인 송금 서비스)
// - RVS(Relative Version System, 상대 버전 시스템)
// - CVS(Concurrent Version System, 동시 버전 관리 시스템)
// 소프트웨어 프로젝트를 진행할 때, 파일로 이뤄진 모든 작업과 모든 변화를 추적하고, 여러 개발자(지역적으로 떨어진)가 협력하여 작업할 수 있게 한다.

// 30. 화이트박스 테스트
// (1) 화이트박스 테스트의 이해를 위해 논리흐름도(Logic-Flow Diagram)를 이용할 수 있다.
// (2) 테스트 데이터를 이용해 실제 프로그램을 실행함으로써 오류를 찾는 동적 테스트(Dynamic Test)에 해당한다.
// (X) 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 프로그램 또는 모듈의 요구나 명세를 기초로 결정한다.
// (4) 테스트 데이터를 선택하기 위해 검증기준(Test Coverage)을 정한다.
// <해설>
// - 블랙박스 테스트 : 프로그램 구조를 고려하지 않는 테스트
// <용어 정리>
// - 정적 테스트 : 소프트웨어를 실행하지 않고 요구사항 정의서, 설계서, 소스 코드 등의 개발 산출물을 테스팅하는 것
// - 동적 테스트 : 실제 구현된 시스템(프로그램)을 실행하여 테스팅하는 것
// - 화이트박스 테스트 : 소프트웨어 또는 컴포넌트 등의 로직에 대한 테스트를 수행하기 위해 설계 단계에서 요구된 사항을 확인하는 개발자 관점의 단위테스팅 기법
// - 블랙박스 테스트 : 소프트웨어의 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어의 동작을 검사하는 방법

// 31. 알고리즘
// (1) 주어진 작업을 수행하는 컴퓨터 명령어를 순서대로 나열한 것으로 볼 수 있다.
// (2) 검색(Searching)은 정렬이 되지 않은 데이터 혹은 정렬이 된 데이터 중에서 키값에 해당되는 데이터를 찾는 알고리즘이다.
// (3) 정렬(Sorting)은 흩어져있는 데이터를 키값을 이용하여 순서대로 열거하는 알고리즘이다.
// (X) 선형 검색은 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.
// <해설>
// - 선형 검색(or 순차 탐색)
// 처음부터 끝까지 하나씩 순서대로 비교하며 원하는 값을 찾아내는 검색
// - 이진 검색
// 검색을 수행하기 전에 반드시 데이터의 집합이 정렬되어 있어야 한다.

// 32. 버블 정렬
// 버블 정렬은 첫번째 원소부터 마지막 원소까지 순서대로 바로 오른쪽 원소와 값을 비교해가면서 데이터를 정렬하는 기법이다.
// pass 1 : 첫 버블의 정렬이 끝난 상태
// <예시> 9, 6, 7, 3, 5 오름차순 버블 정렬 pass 1
// 9와 6을 비교 -> 69735 -> 9와 7을 비교 -> 67935 -> 9와 3을 비교 -> 67395 -> 9와 5를 비교 -> 67359

// 33. 인스펙션(Inspection) 과정
// 1) 계획
// 2) 사전 교육
// 3) 인스펙션 회의
// 4) 수정 -> 1) 계획
// 5) 후속 조치

// 34. 소프트웨어를 보다 쉽게 이해할 수 있고 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는 것은?
// <해설>
// (1) Refactoring - 결과의 변경 없이 코드의 구조를 재조정함
// (X) Architecting - 기능면에서 바라본 본 구성 방식. 구조, 밑그림(설계 관련)
// (X) Specification(규격, 사양) - 명세서
// (X) Renewal(갱신) - 유지보수
// - 리펙토링과 유지보수는 다른 개념이다.

// 35. 단위 테스트(Unit Test)
// (1) 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지 테스트한다.
// (2) 모듈 내부의 구조를 구체적으로 볼 수 있는 구조적 테스트를 주로 시행한다.
// (X) 필요 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 그 결과값을 받는 역할을 하는 가상의 모듈을 테스트 스텁(Stub)이라고 한다.
// (4) 테스트할 모듈을 호출하는 모듈도 있고, 테스트할 모듈이 호출하는 모듈도 있다.
// <해설>
// - 테스트 드라이버(Test Driver)
// 상위 모듈의 역할을 하는 가상의 모듈로서 테스트할 모듈을 호출하는 역할을 한다.
// 즉, 필요한 데이터를 인자를 통해 넘겨주고 테스트가 완료된 후 그 결과값을 받는 역할을 한다.
// - 테스트 스텀(Test Stub)
// 테스트 완료 후 그 결과값을 받는 역할을 하는 가상 모듈.

// 36. IDE(Integrated Development Environment) 도구의 각 기능에 대한 설명
// (1) Coding - 프로그래밍 언어를 가지고 컴퓨터 프로그램을 작성할 수 있는 환경을 제공
// (X) Compile - 저급언어의 프로그램을 고급언어 프로그램으로 변환하는 기능
// (3) Debugging - 프로그램에서 발견되는 버그를 찾아 수정할 수 있는 기능
// (4) Deployment - 소프트웨어를 최종 사용자에게 전달하기 위한 기능
// <해설>
// - Compile : 주어진 언어로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 기능
// - 컴파일은 고급언어(사람이 인식하는 언어)를 저급언어(기계어)로 변환하는 기능이다.

// 37. 후위 순회(Post-order Traverse)
// <해설>
// - 이진 나무 순회(Tree Traverse) 종류
// 1) 전위 순회(Pre-order Traverse)
// 뿌리(Root)를 먼저 방문 == Root, Left, Right 순서
// 2) 중위 순회(In-order Traverse)
// 왼쪽 하위 트리를 방문 후 뿌리(Root)를 방문 == Left, Root, Right 순서
// 3) 후위 순회(Post-order Traverse)
// 하위 트리 모두 방문 후 뿌리(Root)를 방문 == Left, Right, Root 순서
// 4) 층별 순회(Lever-order Traverse)
// 위 쪽 node들부터 아래 방향으로 차례로 방문 == node의 순서대로
// <용어 정리>
// - path : edge에 의해 연결된 node들의 집합
// - root node : 최상위의 node
// - parent(부모), children(자식), sibling(형제), grandparent(조부모), ancestor(조상)
// 기준이 되는 것의 바로 직계 상위 node를 부모, 바로 아래층의 node를 자식, 같은 부모를 둔 node들을 형제, 부모의 부모를 조부모, 직계 상위 노드들은 조상
// - leaf(잎) : 자식이 없는 node
// - subtree(하위 나무) : 큰 tree에 속한 작은 tree
// - node의 degree : 특정 node의 subtree 개수
// - node의 level : root node 부터 최하위 node까지의 중첩되지 않은 path의 node 개수

// 38. 인터페이스 구현 시 사용하는 기술로 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷은?
// (1) JSON
// (X) HTML
// (X) AVPN
// (X) DOF
// <해설>
// - JSON(JavaScript Object Notation)
// 속성-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷이다.
// AJAX(Asynchronous Javascript And Xml)에서 많이 사용되고 XML을 대체하는 주요 데이터 포맷이다.
// 언어 독립형 데이터 포맷으로 다양한 프로그래밍 언어에서 사용되고 있다.
// <용어 정리>
// - DOF(Depth of Focus, 심도)
// - AJAX(Asynchronous Javascript And Xml) (asynchronous : 비동기적인)
// Ajax는 빠르게 동작하는 동적인 웹 페이지를 만들기 위한 개발 기법의 하나이다.
// Ajax는 웹 페이지 전체를 다시 로딩하지 않고도, 웹 페이지의 일부분만을 갱신할 수 있다.
// 즉, Ajax를 이용하면 백그라운드 영역에서 서버와 통신하여, 그 결과를 웹 페이지의 일부분에만 표시할 수 있다.

// 39. 순서가 있는 리스트에서 데이터의 삽입(Push), 삭제(Pop)가 한 쪽 끝에서 일어나며 LIFO(Last-In-First-Out)의 특징을 가지는 자료구조는?
// (X) Tree
// (X) Graph
// (3) Stack
// (X) Queue
// <해설>
// - Stack : LIFO(Last-In-First-Out), 한 쪽 끝에서 일어남
// - Queue : FIFO(First-In-First-Out), 양방향에서 일어남
// - Tree & Graph : 비선형 구조

// 40. 단위 테스트 도구
// (1) CppUnit
// (2) JUnit
// (3) HttpUnit
// (X) IgpUnit
// <해설>
// - CppUnit : C++ 프로그래밍 언어용 단위 테스트 도구
// - JUnit : 자바 프로그래밍 언어용 단위 테스트 도구
// - HttpUnit : 웹 브라우저 없이 웹 사이트 테스트를 수행하는 데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크
// <용어 정리>
// - IgpUnit : 없는 단어

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 데이터베이스 구축

// 41. 다음 조건을 모두 만족하는 정규형은?
// - 테이블 R에 속한 모든 도메인이 원자값만으로 구성되어 있다.
// - 테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며, 키의 부분 집합이 결정자가 되는 부분 종속이 존재하지 않는다.
// - 테이블 R에 존재하는 모든 함수적 종속에서 결정자가 후보키이다.
// (1) BCNF
// (X) 제 1정규형
// (X) 제 2정규형
// (X) 제 3정규형
// <해설>
// 정규화 과정(도부이결다조)
// - 1NF : 모든 *도*메인이 원자 값으로만 구성
// - 2NF : 기본키가 아닌 속성이 기본키에 대한 완전 함수적 종속을 만족, *부*분적 함수 종속을 제거한 정규형
// - 3NF : 기본키가 아닌 모든 속성이 기본키에 대해 *이*행적 함수 종속 관계를 만족하지 않는 정규형
// - BCNF : 모든 *결*정자가 후보키인 정규형, 종속성 보존 X
// - 4NF : *다*치 종속이 성립하는 경우, R의 모든 속성이 A에 함수적 종속 관계를 만족
// - 5NF : 모든 *조*인 종속이 R의 후보키를 통해서만 성립되는 정규형
// <내용 정리>
// Relation-Normalization.js 참고

// 42. 데이터베이스의 트랜잭션 성질들 중에서 다음 설명에 해당하는 것은?
// - 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 원래 상태가 되도록 해야 한다.
// <해설>
// (1) Atomicity(원자성) : 완전하게 수행 완료되지 않으면 전혀 수행되지 않아야 함.
// (X) Consistency(일관성) : 시스템의 고정 요소는 트랜잭션 수행 전후에 같아야 함.
// (X) Isolation(격리성 or 고립성) : 트랜잭션 실행 시 다른 트랜잭션의 간섭을 받지 않아야 함.
// (X) Durability(영속성 or 지속성) : 트랜잭션의 완료 결과가 데이터베이스에 영구히 기억됨.
// <용어 정리>
// - 트랜잭션(Transaction) : "쪼갤 수 없는 업무 처리의 최소 단위"를 말한다. 거래내역이라고도 한다.

// 43. 분산 데이터베이스 시스템
// (1) 물리적으로 분산된 데이터베이스 시스템을 논리적으로 하나의 데이터베이스 시스템처럼 사용할 수 있도록 한 것이다.
// (2) 물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(Local Computer)를 분산 처리기(Distributed Processor)라고 한다.
// (3) 분산 데이터베이스 시스템을 위한 통신 네트워크 구조가 데이터 통신에 영향을 주므로 효율적으로 설계해야 한다.
// (X) 데이터베이스가 분산되어 있음을 사용자가 인식할 수 있도록 분산 투명성(Distribution Transparency)을 배재해야 한다.
// <해설>
// - 분산 데이터베이스의 목표
// 1) 위치 투명성(Location Transparency)
// 하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요가 없다.
// 2) 중복(or 복제) 투명성(Replication Transparency)
// 사용자에게 통지할 필요없이 시스템 안에 파일들과 자원들의 부가적인 복사를 자유롭게 할 수 있다.
// 3) 병행 투명성(Concurrency Transparency)
// 다중 사용자들이 자원들을 공동으로 공유할 수 있다.
// 4) 장애 투명성(Failure Transparency)
// 사용자들은 어느 위치의 시스템에 장애가 발생했는지 알 필요가 없다.
// <내용 정리>
// Distributed-Database-System.js 참고

// 44. SQL 구문
// SELECT (속성명) FROM (테이블명) WHERE (조건) ORDERED BY (속성명 ASC(오름차순 : default) or DESC(내림차순))

// 45. 데이터베이스의 인덱스
// (1) 문헌의 색인, 사전과 같이 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조이다.
// (2) 테이블에 붙여진 색인으로 데이터 검색 시 처리 속도 향상에 도움이 된다.
// (X) 인덱스의 추가, 삭제 명령어는 각각 ADD, DELETE이다.
// (4) 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다.
// <해설>
// - 인덱스(Index)
// 데이터베이스 성능에 많은 영향을 주는 DBMS의 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하며,
// 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 별도로 구성한 순서 데이터를 말한다.
// 대부분의 데이터베이스에서 테이블을 삭제하면 인덱스도 같이 삭제된다.
// - 인덱스 생성 명령어 : CREATE
// - 인덱스 삭제 명령어 : DROP
// <용어 정리>
// - 클러스터(Cluster)
// 데이터베이스에서 클러스터란 여러개의 서버가 하나의 데이터베이스를 나눠서 처리하는 형태를 뜻한다.
// 고가용성, 병렬처리, 성능향상 이러한 3가지를 만족하는 시스템의 구성형태를 데이터베이스 클러스터라고 한다.
// 컴퓨터 클러스터란 여러 대의 컴퓨터들이 연결되어서 하나의 시스템처럼 동작하는 컴퓨터들의 집합을 말한다. 여러개의 객체를 하나로 모은다는 개념을 가지고 있다.
// DB 클러스터도 똑같은 맥락이다. DB 서버를 여러개 둔다고 생각하면 된다. 이에 대한 기본적인 장점은 서버 한 대가 죽어도 대비가 가능하다는 점이다.
// DB 클러스터와 비슷한 형태로 복수개의 독립된 DB가 서로 연계되는 경우가 있다. 이 DB는 서로 데이터를 읽거나 쓰는데, DBLink 또는 SQL/MED라고 한다.
// - DB 클러스터의 용도
// 1) 고가용성(High Availability)
// 서버와 네트워크, 프로그램 등의 정보 시스템이 상당히 오랜 기간 동안 지속적으로 정상 운영이 가능한 성질을 말한다.
// 고가용성이란 "가용성이 높다"는 뜻으로서, "절대 고장 나지 않음"을 의미한다.
// 2) 병렬처리(Analytic)
// DB를 복수개의 작은 단위로 분해해서 각각을 분석하여 처리하는 것
// 3) 성능향상(Online)
// DB 유저수가 막대해지는 케이스는, Web계 어플리케이션에서 자주 발생한다.
// 대규모 Web 어플리케이션의 경우 DB의 복사본을 만들어서 그 DB를 사용하게 하는 방법인 참조 처리로 유저수가 많아지는 것을 대비할 수 있다.

// 46. 물리적 데이터베이스 구조의 기본 데이터 단위인 저장 레코드 양식을 설계할 때 고려 사항
// (1) 데이터 타입
// (2) 데이터 값의 분포
// (X) 트랜잭션 모델링
// (4) 접근 빈도
// <해설>
// - 저장 레코드 양식 설계 시 고려 사항
// 데이터 타입, 데이터 값의 분포, 접근 빈도
// - 트랜잭션 모델링 : 개념적 설계 단계에서 한다.
// 트랜잭션을 개념적 시스템과 독립적으로 정의한다.
// 트랜잭션의 입출력 기능, 형태만 정의한다.
// 검색, 갱신, 혼합(검색 & 갱신)
// <내용 정리>
// - 데이터베이스 설계
// 1) 요구사항 분석
// 사용자의 요구사항을 수집, 분석하여 개발할 데이터베이스의 용도를 파악한다.
// 업무에 필요한 데이터, 데이터를 이용한 처리 방향 등을 고려한다.
// 결과물 : 요구사항 명세서
// 2) 개념적 설계
// DBMS에 독립적인 개념적 스키마 설계
// 요구사항 명세서를 개념적 구조로 표현한다.
// 결과물 : E-R 다이어그램(Entity-Relation Diagram)
// - E-R 다이어그램(Entity-Relation Diagram, ERD)
// 현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해서 가장 널리 사용되고 있는 모델
// 개념적 모델링의 대표적인 도구
// 1대 1, 1대 다, 다대 다를 표현할 수 있고, ERD 표준기호와 새발 표기법을 사용하여 표기한다.
// 3) 논리적 설계
// DBMS에 적합한 논리적 구조 설계
// 결과물 : 논리적 스키마(릴레이션 스키마)
// 4) 물리적 설계
// DBMS로 구현 가능한 물리적 구조 설계
// 결과물 : 물리적 스키마
// 5) 구현
// 데이터베이스 생성

// 47. SQL 기능에 따른 분류 중에서 REVOKE문과 같이 데이터의 사용 권한을 관리하는 데 사용하는 언어는?
// (X) DDL(Data Definition Language)
// (X) DML(Data Manipulation Language)
// (3) DCL(Data Control Language)
// (X) DUL(Data User Language)
// <내용 정리>
// - DDL(Data Definition Language)
// 주로 데이터베이스 관리자나 데이터 베이스 설계자가 데이터베이스 스키마를 정의하거나 조작하기 위한 언어이다.
// 생성, 수정, 삭제 등의 데이터 전체 골격을 결정하는 역할을 담당한다.
// DDL의 데이터 정의어(CREATE, ALTER, DROP)
// 1) CREATE : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 정의
// 2) ALTER : TABLE에 대한 정의를 변경하는 데 사용
// 3) DROP : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 삭제
// - DML(Data Manipulation Language)
// 저장된 데이터를 실질적으로 처리하는 데 사용하는 언어이다.
// 데이터 베이스 사용자와 데이터 베이스 관리 시스템 간의 인터페이스를 제공한다.
// DML 레코드 제어 명령어(SELECT, INSERT, DELETE, UPDATE)
// 1) SELECT : 테이블에서 조건에 맞는 튜플을 검색
// 2) INSERT : 테이블에 새로운 튜플을 삽입
// 3) DELETE : 테이블에서 조건에 맞는 튜플을 삭제
// 4) UPDATE : 테이블에서 조건에 맞는 튜플의 내용을 변경
// - DCL(Data Control Language)
// 객체 권한 부여 등의 제어어로 데이터의 보안, 무결성, 데이터 회복, 병행 수행 제어 등을 정의하는 데 사용하는 언어이다.
// 데이터 베이스 관리자가 데이터 관리를 목적으로 사용한다.
// DCL 데이터 제어어(COMMIT, ROLLBACK, GRANT, REVOKE)
// 1) COMMIT : 명령어로 수행된 결과를 실제 물리적 디스크로 저장하고, 명령어로 수행을 성공적으로 완료하였음을 선언한다.
// 2) ROLLBACK : 명령어로 수행을 실패하였음을 알리고, 수행된 결과를 원상복구시킨다.
// 3) GRANT : 데이터베이스 사용자에게 사용 권한을 부여한다.
// 4) REVOKE : 데이터베이스 사용자로부터 사용 권한을 취소한다.
// - DUL(Data User Language) : 없는 단어

// 48. 데이터 사전
// (1) 시스템 카탈로그 또는 시스템 데이터베이스라고도 한다.
// (X) 데이터 사전 역시 데이터베이스의 일종이므로 일반 사용자가 생성, 유지 및 수정할 수 있다.
// (3) 데이터베이스에 대한 데이터인 메타데이터(Metadata)를 저장하고 있다.
// (4) 데이터 사전에 있는 데이터에 실제로 접근하는 데 필요한 위치 정보는 데이터 디렉토리(Data Directory)라는 곳에서 관리한다.
// <해설>
// - 데이터 사전(Data Dictionary, DD)
// 시스템 자신이 필요로 하는 여러가지 객체(기본 테이블, 뷰, 인덱스, 데이터베이스, 패키지, 접근 권한 등)에 관한 정보를 포함하고 있는 시스템 데이터베이스이다.
// 시스템 카탈로그(System Catalog), 메타 데이터(Meta Data)라고도 한다.
// 시스템 카탈로그 자체도 시스템 테이블로 구성되어 있어 SQL문을 이용하여 내용 검색이 가능하다.
// 사용자가 시스템 카탈로그를 직접 갱신할 수 없다.
// SQL문으로 여러가지 객체에 변화를 주면 시스템이 자동으로 갱신한다.

// 49. 데이터베이스에서 릴레이션
// (1) 모든 튜플은 서로 다른 값을 가지고 있다.
// (X) 하나의 릴레이션에서 튜플은 특정한 순서를 가진다.
// (3) 각 속성은 릴레이션 내에서 유일한 이름을 가진다.
// (4) 모든 속성 값은 원자 값(atomic value)을 가진다.
// <해설>
// - 튜플의 순서는 정해져있지 않다.

// 50. 데이터베이스에서의 뷰(View)
// (1) 뷰는 다른 뷰를 기반으로 새로운 뷰를 만들 수 있다.
// (2) 뷰는 일종의 가상 테이블이며, update에는 제약이 따른다.
// (3) 뷰는 기본 테이블을 만드는 것처럼 create view를 사용하여 만들 수 있다.
// (X) 뷰는 논리적으로 존재하는 기본 테이블과 다르게 물리적으로만 존재하며 카탈로그에 저장된다.
// <해설>
// - 뷰는 논리적으로만 존재한다.
// <내용 정리>
// -(데이터베이스에서) 뷰(View)
// 1) 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.
// 2) 뷰는 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는 것처럼 간주된다.
// 3) 뷰는 데이터 보정작업, 처리과정 시험 등 임시적인 작업을 위한 용도로 활용된다.
// 4) 뷰는 조인문의 사용 최소화로 사용상의 편의성을 최대화 한다.
// - 뷰(View)의 특징
// 1) 뷰는 기본테이블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다.
// 2) 뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않다.
// 3) 데이터의 논리적 독립성을 제공할 수 있다.
// 4) 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
// 5) 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다.
// 6) 기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야지만 삽입, 삭제, 갱신, 연산이 가능하다.
// 7) 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
// 8) 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다.
// - 뷰(View) 사용시 장점
// 1) 논리적 데이터 독립성을 제공한다.
// 2) 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원해 준다.
// 3) 사용자의 데이터관리를 간단하게 해준다.
// 4) 접근 제어를 통한 자동 보안이 제공된다.
// - 뷰(View) 사용시 단점
// 1) 독립적인 인덱스를 가질 수 없다.
// 2) ALTER VIEW문을 사용할 수 없다. 즉 뷰의 정의를 변경할 수 없다.
// 3) 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따른다.

// 51. 트랜잭션의 상태 중 트랜잭션의 마지막 연산이 실행된 직후의 상태로,
// 모든 연산의 처리는 끝났지만 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하지 않은 상태는?
// (X) Active
// (2) Partially Committed
// (X) Committed(처리)
// (X) Aborted(중단)
// <해설>
// - Partially Committed : 마지막 연산이 실행된 직후의 상태로 아직 Commit 연산 실행 전
// - Committed : 트랜잭션이 실행을 성공적으로 완료하여 Commit 연산을 수행한 상태
// - 트랜잭션 과정
// Active -> Partially Committed -> Committed
//                  ㅣㅡ> Failed -> Aborted(Rollback 연산)

// 52. SQL의 명령을 사용 용도에 따라 DDL, DML, DCL로 구분할 경우, 그 성격이 나머지 셋과 다른 것은?
// (X) SELECT
// (X) UPDATE
// (X) INSERT
// (4) GRANT
// <해설>
// - DML(Data Manipulation Language)
// 1) SELECT : 테이블에서 조건에 맞는 튜플을 검색
// 2) INSERT : 테이블에 새로운 튜플을 삽입
// 3) UPDATE : 테이블에서 조건에 맞는 튜플의 내용 갱신
// 4) DELETE : 테이블에서 조건에 맞는 튜플 삭제
// - DCL(Data Control Language)
// 1) COMMIT : 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료됐음을 알려주는 명령어
// 2) ROLLBACK : 아직 COMMIT되지 않은 변경된 모든 내용들을 취소하고, 데이터베이스를 이전 상태로 되돌리는 명령어
// 3) GRANT : 데이터베이스 사용자에게 사용 권한 부여
// 4) REVOKE : 데이터베이스 사용자의 사용 권한 취소
// - DDL(Data Definition Language)
// 1) CREATE : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 정의
// 2) ALTER : TABLE에 대한 정의를 변경하는 데 사용
// 3) DROP : SCHEMA(스키마), DOMAIN(도메인), TABLE(테이블), VIEW(뷰), INDEX(인덱스)를 삭제

// 53. 키의 종류 중 유일성과 최소성을 만족하는 속성 또는 속성들의 집합은?
// (X) Atomic Key
// (X) Super Key(슈퍼키)
// (3) Candidate Key(후보키)
// (X) Test Key
// <해설>
// - Super Key(슈퍼키) : 속성들의 집합으로 구성된 키, 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다(유일성만 만족).
// - Candidate Key(후보키) : 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합(유일성, 최소성 만족)

// 54. 데이터베이스에서 개념적 설계 단계
// (1) 산출물로 E-R Diagram을 만들 수 있다.
// (2) DBMS에 독립적인 개념 스키마를 설계한다.
// (X) 트랜잭션 인터페이스를 설계 및 작성한다.
// (4) 논리적 설계 단계의 앞 단계에서 수행된다.
// <해설>
// - 데이터베이스 설계 단계에서의 트랜잭션 설계 단계
// 1) 개념 설계
// 트랜잭션 모델링, 독립적인 개념 스키마 모델링, 개념 스키마 설계, E-R Diagram
// 2) 논리 설계
// 트랜잭션 인터페이스 설계, DBMS에 맞는 논리 스키마 설계, 테이블 설계, 논리적 매핑, 스키마 평가 및 정제
// 3) 물리 설계 : 트랜잭션 세부 설계
// 레코드에 초점을 맞춘 분석 및 설계, 저장 레코드 양식 설계, 저장 구조 및 액세스 경로 설정

// 55. 테이블의 기본키(Primary Key)로 지정된 속성
// (1) NOT NULL로 널 값을 가지지 않는다.
// (2) 릴레이션에서 튜플을 구별할 수 있다.
// (3) 외래키로 참조될 수 있다.
// (X) 검색할 때 반드시 필요하다.
// <해설>
// - 기본키 설명
// 후보키 중에서 선정된 주키(MAIN KEY)로 중복된 값을 가질 수 없다.
// 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다(유일성).
// 기본키는 후보키의 성질을 갖는다(유일성, 최소성). 즉, 튜플을 식별하기 위해 반드시 필요한 키
// 기본키는 NULL 값을 가질 수 없다. 즉, 기본키로 설정된 속성에는 NULL 값이 있어서는 안된다.

// 56. 데이터 모델의 구성요소 중 데이터 구조에 따라 개념 설계나 컴퓨터 세계에서 실제로 표현된 값들을 처리하는 작업을 의미하는 것은?
// (X) Relation
// (X) Data Structure
// (X) Constraint
// (4) Operation
// <해설>
// - 데이터 모델 정의
// 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화한 체계적인 개념적 모형을 말한다.
// 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 사용되는 지능적인 도구
// - 데이터 모델의 구성 요소
// 1) 개체(Entity) : 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
// 2) 속성(Attribute) : 가장 작은 논리적 단위, 데이터 항목, 데이터 필드
// 3) 관계(Relationship) : 개체 간의 관계, 속성 간의 논리적인 연결
// - 데이터 모델 종류
// 1) 개념적 데이터 모델
// 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정.
// 대표적인 개념적 데이터 모델로는 E-R 모델이 있다.
// 2) 논리적 데이터 모델
// 개념적 모델링 과정에서 얻은 구조를 컴퓨터가 이해하고 처리할 수 있게 변환하는 과정.
// '정규화' 작업이 논리적 데이터 모델링에 해당한다.
// 3) 물리적 데이터 모델
// 실질적 데이터 구조 설계로, 테이블 정의서, 명세서 등이 있다.
// - 데이터 모델에 표시할 요소
// 1) 구조(Structure) : 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질을 표현
// 2) 연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세로, 조작하는 기본 도구
// 3) 제약조건(Constraint) : DB에 저장될 수 있는 실제 데이터의 논리적인 제약조건

// 57. SQL문 SELECT
// SELECT (속성) FROM (테이블) WHERE (조건)
// 문제 : 이름이 '정도일'인 팀원이 소속된 팀코드를 이용하여 해당 팀에 소속된 팀원들의 이름을 출력하는 SQL문 작성
// 테이블 : 직원, 속성 : 팀코드, 이름
// SELECT 이름 FROM 직원 WHERE (팀코드 = (SELECT 팀코드 FROM 직원 WHERE 이름 = '정도일'))

// 58. 무결성 제약조건 중 개체 무결성 제약조건
// (X) 릴레이션 내의 튜플들이 각 속성의 도메인에 정해진 값만을 가져야 한다.
// (2) 기본키는 NULL 값을 가져서는 안되며 릴레이션 내에 오직 하나의 값만 존재해야 한다.
// (X) 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 한다.
// (X) 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받는다.
// <해설>
// - 기본키(Primary Key)
// 테이블의 각 레코드를 고유하게 식별하는 필드나 필드의 집합이다.
// 테이블에 기본키 설정을 필수가 아니다.
// 기본키를 설정하지 않고도 다른 테이블과의 관계를 설정할 수 있다.
// 기본키는 혼합 속성(다수 필드)에 설정할 수 있다.
// - 데이터 무결성(Data Integrity) 제약조건(Constraint) 종류
// 1) 개체 무결성(Entity Integrity)
// 기본키 제약이라고도 하며, 테이블은 기본키를 지정하고 그에 따른 무결성 원칙을 지켜야 하는 조건이다.
// 기본키에는 NULL 값이 올 수 없다.
// 기본키는 테이블 내에 오직 하나의 값만 존재해야 한다(하나의 테이블 내에 동일한 기본키를 가진 레코드는 존재할 수 없음).
// 2) 참조 무결성(Referential Integrity)
// 외래키 제약이라고도 하며, 테이블 간의 참조 관계를 선언하는 제약조건
// 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다.
// 외래키 속성은 참조할 수 없는 값을 지닐 수 없다(외래키 속성값이 상위 테이블의 인스턴스에 반드시 존재하거나 NULL이어야 함).
// 3) 도메인 무결성(Domain Integrity)
// 테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로, 필드의 타입, NULL 값 허용 등에 대한 사항을 정의하고 올바른 데이터가 입력되었는지 확인하는 조건
// 예를 들어, 주민등록번호 필드에 문자가 입력되는 경우에는 도메인 무결성이 깨졌다고 볼 수 있다.
// 속성들의 값은 정의된 도메인에 속한 값이어야 한다.
// 4) 고유 무결성
// 테이블의 특정 속성에 대해 각 레코드들이 갖는 값들이 서로 달라야 하는 조건
// 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 한다.
// 5) NULL 무결성
// 테이블의 특정 속성 값이 NULL 값이 될 수 없게 하는 조건
// 릴레이션의 특정 속성 값은 NULL 값이 될 수 없다.
// 6) 키 무결성
// 하나의 테이블에 적어도 하나의 키가 존재해야 하는 조건
// 각 릴레이션은 최소한 한 개 이상의 키가 존재해야 한다.
// - 무결성 제약조건 장점
// 스키마를 정의할 때 일관성 조건을 오직 한 번만 명시하고,
// 데이터베이스가 갱신될 때 DBMS가 자동으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없다.
// - 무결성 제약조건 단점
// 무결성 제약조건을 반복해서 구현해야 하므로 프로그래밍 작업이 훨씬 복잡해지고, 무결성 제약조건들 간에 서로 충돌이 발생할 수 있다.
// <용어 정리>
// - 개체(Entity) : 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 단위이다.
// - 무결성(Integrity) : 데이터의 정확성과 일관성을 유지하고 보증하는 것을 가리키며 데이터베이스나 RDBMS 시스템의 중요한 기능이다.
// - 정확성(Correctness) : 중복이나 누락이 없는 상태
// - 일관성(Consistency) : 원인과 결과의 의미가 연속적으로 보장되어 변하지 않는 상태

// 59. 관계 데이터베이스 모델에서 릴레이션(Relation)에 포함되어 있는 튜플(Tuple)의 수를 무엇이라고 하는가?
// (X) Degree
// (2) Cardinality
// (X) Attribute
// (X) Cartesian product
// <해설>
// - 차수(Degree) : 속성의 수(열의 개수)
// - 카디널리티(Cardinality) : 튜플의 수(행의 개수)
// - 속성(Attribute) : 릴레이션에서 열
// - 카테시안 곱(Cartesian product)
// From절에 2개 이상의 Table이 있을때 두 Table 사이에 유효 join 조건을 적지 않았을때,
// 해당 테이블에 대한 모든 데이터를 전부 결합하여 Table에 존재하는 행 갯수를 곱한 만큼의 결과값이 반환되는 것이다.

// 60. SQL문 GRANT
// 문제1 : 사용자 'PARK'에게 테이블을 생성할 수 있는 권한을 부여하기 위한 SQL문
// GRANT CREATE TABLE PARK;
// SQL문 의미 : PARK에게 [CREATE TABLE] 권한을 부여한다.
// 문제2 : 사용자 'PARK'에게 테이블을 생성할 수 있는 권한을 취소하기 위한 SQL문
// REVOKE CREATE TABLE FROM PARK;
// SQL문 의미 : PARK으로부터 [CREATE TABLE] 권한을 취소한다.

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 프로그래밍 언어 활용

// 61. C언어에서 문자열 처리 함수의 서식과 그 기능
// (1) strlen(s) - s의 길이를 구한다.
// (2) strcpy(s1, s2) - s1을 s2로 복사한다.
// (X) strcmp(s1, s2) - s1과 s2를 연결한다.
// (4) strrev(s) - s를 거꾸로 변환한다.
// <해설>
// - strcat(s1, s2) : s1과 s2를 연결한다(문자열 연결 함수).
// - strcmp(s1, s2) : s1과 s2를 비교하여 같다면 0, 다르다면 (s1의 아스키코드 - s2의 아스키코드)의 결과에 따라 -1 또는 1을 반환한다.(문자열 비교 함수)

// 62. C언어 프로그램
// && : and 연산
// || : or 연산
// ! : not 연산
// - C언어에서 true는 0이 아닌 수, false는 0으로 간주된다.

// 64. IP 프로토콜에서 사용하는 필드
// (1) Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
// (X) Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 2^32 - 1비트이다.
// (3) Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
// (4) Version Number는 IP 프로토콜의 버전번호를 나타낸다.
// <해설>
// - Total Packet Length(16bits)
// IP 헤더 및 데이터를 포함한 IP 패킷 전체의 길이를 바이트 단위로 표시(최대값은 2^16 - 1 = 65,535)
// <내용 정리>
// - 프로토콜(Protocol)
// 복수의 컴퓨터 사이나 중앙 컴퓨터와 단말기 사이에서 데이터 통신을 원활하게 하기 위해 필요한 통신 규약.
// 신호 송신의 순서, 데이터의 표현법, 오류 검출법 등을 정함.
// - 헤더(Header)
// 데이터 앞 부분에 파일에 대한 정보를 실어놓은 부분
// 주로 데이터 형식에 대한 정보나 시간 데이터, 주소 데이터로 구성되어 있고 데이터의 종류에 따라 정리되기 쉽게 규격화해 놓은 데이터이다.
// 각 레이어는 아래 위로 인접한 층과 연계하여 통신을 처리한다.
// - 패킷(Packet)
// 네트워크를 통해 전송하기 쉽도록 자른 데이터의 전송 단위이다.
// 본래는 소포를 뜻하는 용어로, 소화물을 뜻하는 패키지(package)와 덩어리를 뜻하는 버킷(bucket)의 합성어이다.
// - IP(Internet Protocol) : 인터넷이 통하는 네트워크에서 어떤 정보를 수신하고 송신하는 통신에 대한 규약

// 66. RIP 라우팅 프로토콜
// (1) 경로 선택 메트릭은 홉 카운트(hop count)이다.
// (X) 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.
// (3) 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용한다.
// (4) 각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우터 표를 갱신한다.
// <해설>
// - RIP(Routing Information Protocol)
// 거리 벡터 라우팅 프로토콜
// 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 IGP에 해당한다.
// 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용한다.
// 최적의 경로를 산출하기 위한 정보로서 홉(거리 값)만을 고려하므로, RIP를 선택한 경로가 최적의 경로가 아닌 경우가 종종 발생할 수 있다.
// 소규모 네트워크 환경에 적합하다.
// 최대 홉 카운트를 15홉 이하로 한정하고 있다.
// <내용 정리>
// - Routing-Protocol.js 참고

// 67. 다음에서 설명하는 프로세스 스케줄링은?
// - 최소 작업 우선(SJF) 기법의 약점을 보완한 비선점 스케줄링 기법으로 다음과 같은 식을 이용해 우선순위를 판별한다.
// - 우선순위 = (대기한 시간 + 서비스를 받을 시간) / (서비스를 받을 시간)
// (X) FIFO 스케줄링
// (X) RR 스케줄링
// (3) HRN 스케줄링
// (X) MQ 스케줄링
// <해설>
// - HRN(Highest Response-ratio Next) 스케줄링 방식(비선점 스케줄링)
// 실행시간이 긴 프로세스에 불리한 SJF(Shortest Job First)를 보완하기 위해 대기시간 및 서비스 시간을 이용한다.
// SJF 방식의 시간이 오래 걸리는 작업과 빨리 끝나는 작업 간의 지나친 불평등을 해소할 수 있다.
// 시스템 응답시간 = (대기한 시간 + 서비스 시간( == 실행 시간)) / (서비스 시간)
// 시스템 응답시간을 계산하여 숫자가 큰 것부터 작은 순으로 순위를 부여한다(시스템 응답시간 값이 클수록 우선순위가 높음).
// <내용 정리>
// - Scheduling.js 참고

// 68. UNIX 운영체제에 관한 특징
// (1) 하나 이상의 작업에 대하여 백그라운드에서 수행이 가능하다.
// (X) Multi-User는 지원하지만 Multi-Tasking은 지원하지 않는다.
// (3) 트리 구조의 파일 시스템을 갖는다.
// (4) 이식성이 높으며 장치 간의 호환성이 높다.
// <해설>
// - UNIX 운영체제
// 주로 서버용 컴퓨터에서 사용된다.
// time sharing system을 위해 설계된 대화식 운영체제이다.
// C언어로 작성되어 이식성이 높고, 장치간 호환성이 높다.
// Multi-User, Multi-Tasking을 모두 지원한다.
// 트리 구조의 파일 시스템이다.

// 69. UDP 프로토콜의 특징
// (1) 비연결 서비스를 제공한다.
// (2) 단순한 헤더 구조로 오버헤드가 적다
// (X) 주로 주소를 지정하고, 경로를 설정하는 기능을 한다.
// (4) TCP와 같이 트랜스포트 계층에 존재한다.
// <해설>
// - UDP(User Datagram Protocol)
// 비연결형 및 비신뢰성 전송 서비스를 제공한다.
// 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.
// 수신된 데이터의 순서 재조정 기능을 지원하지 않는다.
// 복구 기능을 제공하지 않는다.
// 단순한 헤더 구조로 오버헤드가 적다.
// TCP와 같이 트랜스포트 계층에 존재한다.
// - (3)은 IP Protocol에 관한 설명이다.

// 70. Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며
// 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것은?
// (X) 복소수(complex) 타입
// (X) 리스트(list) 타입
// (X) 사전(dict) 타입
// (4) 튜플(tuple) 타입
// <해설>
// - 시퀀스 데이터 타입 : 순서가 있는 데이터 타입
// - 리스트 타입 : 가변형
// - 튜플 타입 : 불변형
// - 세트 : 순서가 없고, 중복이 없는 데이터 타입
// - 딕셔터리 : 순서 없고, key-value의 쌍으로 이루어진 데이터 타입

// 73. 다음 중 Myers가 구분한 응집도(Cohesion)의 정도에서 가장 낮은 응집도를 갖는 단계는?
// (X) 순차적 응집도(Sequential Cohesion)
// (X) 기능적 응집도(Functional Cohesion)
// (X) 시간적 응집도(Temporal Cohesion)
// (4) 우연적 응집도(Coincidental Cohesion)
// <해설>
// - 응집도
// 기능적 응집도 > 순차적 응집도 > 교환적 응집도 > 절차적 응집도 > 시간적 응집도 > 논리적 응집도 > 우연적 응집도
// <내용 정리>
// - Coupling-Cohesion.js

// 75. IP 프로토콜의 주요 특징
// (X) 체크섬(Checksum) 기능으로 데이터 체크섬(Data Checksum)만 제공한다.
// (2) 패킷을 분할, 병합하는 기능을 수행하기도 한다.
// (3) 비연결형 서비스를 제공한다.
// (4) Best Effort 원칙에 따른 전송 기능을 제공한다.
// <해설>
// - 데이터 체크섬은 제공하지 않고, 헤더 체크섬만 제공한다.
// <내용 정리>
// - Internet-Protocol.js 참고

// 76. 4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어있다고 가정한다.
// 다음의 순서로 페이지 참조가 발생할 때, LRU 페이지 교체 알고리즘을 사용할 경우 몇 번의 페이지 결함이 발생하는가?
// - 페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5
// (1) 5회
// (X) 6회
// (X) 7회
// (X) 8회
// <해설>
// - LRU(Least Recently Used) 알고리즘
// 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘
// - 결함 : 주기억장치의 페이지가 변동되는 것
// <내용 정리>
// - Page-Replace-Algorithm.js 참고

// 77. 사용자 수준에서 지원되는 스레드(thread)가 커널에서 지원되는 스레드에 비해 가지는 장점
// (X) 한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기할 필요가 없으므로 시스템 성능을 높일 수 있다.
// (X) 동시에 여러 스레드가 커널에 접근할 수 있으므로 여러 스레드가 시스템 호출을 동시에 사용할 수 있다.
// (X) 각 스레드를 개별적으로 관리할 수 있으므로 스레드의 독립적인 스케줄링이 가능하다.
// (4) 커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다.
// <해설>
// - (1), (2), (3) : 커널 수준 스레드의 장점
// <내용 정리>
// - 스레드(thread) : 영어 단어의 뜻은 '실'
// 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.
// 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다.
// - 커널(kernel) : 영어 단어의 뜻은 '핵심'
// 컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램으로, 시스템의 모든 것을 완전히 통제한다.
// 운영 체제의 다른 부분 및 응용 프로그램 수행에 필요한 여러 가지 서비스를 제공한다.
// 컴퓨터의 하드웨어와 직접 상호작용하는 모듈이다.
// 제어 프로그램 중 주기억장치에 상주하는 모듈이다.
// 운영체제를 구성하는 프로세스와 운영체제의 제어 아래에서 수행하는 프로그램에 대한 자원할당을 수행한다.

// 78. 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도는?
// (1) 내용 결합도(Content Coupling)
// (X) 제어 결합도(Control Coupling)
// (X) 공통 결합도(Common Coupling)
// (X) 스탬프 결합도(Stamp Coupling)
// <해설>
// - Coupling-Cohesion.js 참고

// 79. C언어 주소값
// 문제 : a[0]의 주소값이 10일 경우(int형 데이터),
//        (A) printf("%u, ", &a[2]); (B) printf("%u", a);의 실행 결과는(단, int형의 크기는 4byte로 가정)?
// - C언어 출력 타입 종류
// 1) %d : 10진 정수형
// 2) %f : 실수형
// 3) %e : 지수형
// 4) %o : 8진수
// 5) %x : 16진수
// 6) %u : 부호없는 10진수
// 7) %g : 실수형 자동 출력
// 8) %p : 포인터의 주소
// 9) %c : 하나의 문자 출력
// 10) %s : 문자열
// - &변수명 : 변수의 주소를 가리킨다.
// <해설>
// - int형의 크기가 4byte이므로 주소값을 4개씩 가진다.
// - a[0]의 주소값 : 10, 11, 12, 13
// - a[1]의 주소값 : 14, 15, 16, 17
// - a[2]의 주소값 : 18, 19, 20, 21
// - a[3]의 주소값 : 22, 23, 24, 25
// (A) &a[2] : a[2]의 첫 번째 주소값 -> 18
// (B) a : a[0]의 첫 번째 주소값 -> 10

// 80. 모듈화(Modularity)
// (1) 시스템을 모듈로 분할하면 각각의 모듈을 별개로 만들고 수정할 수 있기 때문에 좋은 구조가 된다.
// (X) 응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.
// (3) 모듈 간의 결합도가 약해야 독립적인 모듈이 될 수 있다.
// (4) 모듈 내 구성 요소들 간의 응집도가 강해야 좋은 모듈 설계이다.
// <해설>
// - Coupling-Cohesion.js 참고

//-------------------------------------------------------------------------------------------------------------------------------------------------

// 정보시스템 구축관리

// 81. 소프트웨어 개발에서 정보보안 3요소
// (1) 기밀성 : 인가된 사용자에 대해서만 자원 접근이 가능하다.
// (2) 무결성 : 인가된 사용자에 대해서만 자원 수정이 가능하며 전송중인 정보는 수정되지 않는다.
// (3) 가용성 : 인가된 사용자는 가지고 있는 권한 범위 내에서 언제든 자원 접근이 가능하다.
// (X) 휘발성 : 인가된 사용자가 수행한 데이터는 처리 완료 즉시 폐기되어야 한다.
// <내용 정리>
// - 기밀성 : 사용을 승인받은 사람만 해당 정보에 접근할 수 있는 성질(방화벽, 암호, 비밀번호 등)
// - 무결성 : 적절한 권한을 가진 사용자에 의해 인가된 방법으로만 정보를 변경할 수 있도록 하는 성질
// - 가용성 : 정보 자산에 대해 적절한 시간에 언제든 접근 가능한 성질

// 82. 어떤 외부 컴퓨터가 접속되면 접속 인가 여부를 점검해서 인가된 경우에는 접속이 허용되고, 그 반대의 경우에는 거부할 수 있는 접근제어 유틸리티는?
// (1) tcp wrapper
// (X) trace checker
// (X) token finder
// (X) change detector
// <해설>
// - tcp/ip 통신에서, tcp는 3-way handshake를 통해 통신이 원활히 이뤄질 수 있는지를 확인한다.
// <내용 정리>
// - 호스트 기반 침입 탐지 시스템(Host-based Intrusion Detection System, HIDS)
// 침입 및 오용을 탐지하기 위해 설치된 컴퓨터 시스템을 모니터링하고 활동을 기록하고 지정된 기관에 통지하여 응답하는 시스템
// - BSD(Berkeley Software Distribution)
// 1977 ~ 1995년까지 미국 캘리포니아 대학교 버클리(University of California, Berkeley)의 CSRG(Computer Systems Research Group)에서 개발한 유닉스 운영체제
// 오늘날 BSD라는 용어는 유닉스 계열 운영 체제 계열에서 분기되어 형성된 BSD 파생판을 두루 가리키는 용어로 자리잡혀 있다.
// 오리지널 BSD 코드로부터 파생된 운영 체제들은 현재까지도 활발히 개발되고 널리 사용되고 있다.
// - ACL(Access Control List, 접근 제어 목록)
// 개체나 개체 속성에 적용되어 있는 허가 목록을 말한다.
// 이 목록은 누가 또는 무엇이 객체 접근 허가를 받는지, 어떠한 작업이 객체에 수행되도록 허가를 받을지를 지정하고 있다.
// - tcp wrapper
// 호스트 기반 네트워킹 ACL 시스템으로서, 리눅스 또는 BSD 같은 운영 체제의 인터넷 프로토콜 서버에서 네트워크 접근을 필터링하기 위해 사용된다.
// - trace checker
// 측정 데이터를 자동으로 면밀히 분석하는 도구이다.
// 보고서 형식의 테스트 결과가 필요한 모든 경우에 특히 유용하다.
// 보고서 형식은 읽기 쉽고 해석하기 쉽다.
// 어디에서 수집된 데이터인지 또는 통합하려는 툴체인에 의존하지 않는다.
// - token finder(영어 해석 : 토큰 찾는 도구)
// - change detector(영어 해석 : 변화 감지기)

// 83. 기기를 키오스크에 갖다 대면 원하는 데이터를 바로 가져올 수 있는 기술로
// 10cm 이내 근접 거리에서 기가급 속도로 데이터 전송이 가능한 초고속 근접무선통신(Near Field Communication, NFC) 기술은?
// (X) BcN(Broadband Convergence Network)
// (2) Zing
// (X) Marine Navi
// (X) C-V2X(Cellular Vehicle To Everything)
// <내용 정리>
// - Cell
// 이동 통신에서 하나의 기지국이 포괄하는 지역을 가리키는 개념이다.
// 휴대전화를 뜻하는 영어인 셀룰러 폰(cellular phone)은 여기에서 유래하였다.
// 이동 통신은 제한된 주파수 대역을 다수의 사용자가 이용하므로 주파수의 재활용이 중요한 기술적 요소가 된다.
// - Cellular : 이동 무선 통신에서 셀의 설치에 의해 통신망을 구성, 운용하는 것
// - V2X(Vehicle To Everything)
// 운전 중, 유/무선망을 통하여 다른 차량 및 도로 등 인프라가 구축된 사물과 교통정보와 같은 정보를 교환하는 통신기술이다.
// 본인의 자동차가 도로에 있는 모든 사물, 사람과 Communication 을 할수 있게 해 주는 기술.
// - BcN(Broadband Convergence Network, 광대역통합망)
// 음성·데이터, 유·무선 등 통신·방송·인터넷이 융합된 품질보장형 광대역 멀티미디어 서비스를
// 언제 어디서나 끊김없이(seamless) 안전하게 이용할 수 있는 차세대 통합 네트워를 말한다.
// - Zing
// 근거리무선통신(NFC)보다 8000배 빠른 초고속 근접 통신 기술이다. 한국전자통신연구원(ETRI)이 개발하고 코프가 사업화를 하고 있다.
// 기기를 키오스크에 갖다 대면 원하는 데이터를 바로 가져올 수 있다. 10㎝ 이내 거리에서 3.5Gbps 속도로 데이터를 전송한다.
// - Marine Navi(영어 해석 : 해양 네비게이션)
// - C-V2X(Cellular Vehicle To Everything, 차량 사물 셀룰러 통신)
// C 는 Cellular 의 약자로서 V2X 의 커뮤니케이션 통로를 현재 사용중인 Cellular 망을 이용하는 것이 핵심이다.

// 84. 취약점 관리를 위한 응용 프로그램의 보안 설정
// (X) 서버 관리실 출입 통제
// (2) 실행 프로세스 권한 설정
// (3) 운영체제의 접근 제한
// (4) 운영체제의 정보 수집 제한
// <해설>
// - 응용 프로그램 취약점 관리
// 1) 패치 관리 : 응용 프로그램에 대한 패치 또는 서비스 팩 적용
// 2) 응용 프로그램 실행 권한의 제한 필요
// 3) 운영체제의 접근 제한
// 4) 정보 수집 제한
// 5) 불필요한 서비스 및 악성 프로그램의 확인 및 제거
// 6) 시스템 무결성 검사 : 주요 파일을 검사하여 변경 내역 확인

// 85. 소프트웨어 개발 프레임워크
// (1) 반제품 상태의 제품을 토대로 도메인별로 필요한 서비스 컴포넌트를 사용하여 재사용성 확대와 성능을 보장받을 수 있게 하는 개발 소프트웨어이다.
// (X) 라이브러리와는 달리 사용자 코드에서 프레임워크를 호출해서 사용하고, 그에 대한 제어도 사용자 코드가 가지는 방식이다.
// (3) 설계 관점에 개발 방식을 패턴화시키기 위한 노력의 결과물인 소프트웨어 디자인 패턴을 반제품 소프트웨어 상태로 집적화시킨 것으로 볼 수 있다.
// (4) 프레임워크의 동작 원리를 그 제어 흐름의 일반적인 프로그램과 반대로 동작한다고 해서 IoC(Inversion of Control)이라고 설명하기도 한다.
// <해설>
// - 사용자 코드를 호출해서 사용하고 그에 대한 제어를 할 수 있는 것은 라이브러리이다.
// - 프레임워크는 이미 정해진 코드를 호출해 사용하고 자체적인 흐름을 가지고 있다.

// 86. 클라우드 기반 HSM(Cloud-based Hardware Security Module)
// (1) 클라우드(데이터 센터) 기반 암호화 키 생성, 처리, 저장 등을 하는 보안 기기이다.
// (2) 국내에서는 공인인증제의 폐지와 전자서명법 개정을 추진하면서 클라우드 HSM 용어가 자주 등장하였다.
// (3) 클라우드에 인증서를 저장하므로 기존 HSM 기기나 휴대폰에 인증서를 저장해 다닐 필요가 없다.
// (X) 하드웨어가 아닌 소프트웨어적으로만 구현되기 때문에 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 없다는 것이 주요 단점이다.
// <해설>
// - 하드웨어적으로 구현되므로 소프트웨어식 암호 기술에 내재된 보안 취약점을 해결할 수 있다.
// <내용 정리>
// - 클라우드 기반 HSM(Cloud-based Hardware Security Module)
// 클라우드 시스템을 사용하면서 필요한 각종 암호 키를 보관, 관리하고 암호, 인증, 전자 서명 등에 필요한 암호 알고리즘을 수행한다.
// 클라우드 시스템 내에서 사용되는 보안 관련 설정부터 암호 키 관리, 암호화 서비스 등
// 모든 보안 관련 사항을 서비스로 제공하기 때문에 서비스형 하드웨어 보안 모듈(HSM as a Service)이라고도 한다.
// 클라우드 사용자는 다른 클라우드 자원과 마찬가지로 사용료만 지불하고 HSM 기능을 사용할 수 있다.
// 클라우드 시스템 내의 DB 데이터 암호화 작업 등에 사용하며, 필요한 경우에는 암호 키를 외부의 상용 HSM으로 내보낼 수도 있다.
// cloud HSM 서비스는 IBM의 ‘IBM cloud HSM’, 구글의 ‘Google cloud HSM’, 아마존의 ‘AWS cloud HSM’ 등 클라우드 서비스 업체에서 일반적으로 같이 제공한다.
// 참고로 cloud HSM 제공자는 암호 키를 보관할 때 사용하는 장소와 방법에 따라 FIPS 140-2 Level 3 인증 HSM 보안 등급 규격을 준수해야 한다.
// - 공공인증제
// 국가·공공기관에 보급할 목적으로 평가·인증 신청한 정보보호제품이 국가용 보안요구사항을 만족하는지 검증하는 것을 의미
// - 전자서명
// 서명자를 확인하고 서명자가 해당 전자문서에 서명했다는 사실을 나타내는 데 이용하려고, 특정 전자문서에 첨부되거나 논리적으로 결합된 전자적 형태의 정보

// 87. 다음 내용이 설명하는 기술로 가장 적절한 것은?
// - 다른 국을 향하는 호출이 중계에 의하지 않고 직접 접속되는 그물 모양의 네트워크이다.
// - 통신량이 많은 비교적 소수의 국 사이에 구성될 경우 경제적이며 간편하지만, 다수의 국 사이에는 회선이 세분화되어 비경제적일 수도 있다.
// - 해당 형태의 무선 네트워크의 경우 대용량을 빠르고 안전하게 전달할 수 있어 행사장이나 군 등에서 많이 활용된다.
// (X) Virtual Local Area Network
// (X) Simple Station Network
// (3) Mesh(그물) Network
// (X) Modem Network
// <내용 정리>
// - 엔드포인트(End Point) : 네트워크에 연결하고 네트워크를 통해 통신하는 모든 디바이스
// - LAN(Local Area Network)
// 비교적 가까운 거리에 있는 단말 간의 네트워크를 말한다.
// 따라서 원거리 즉, Wide Area Network의 약자인 WAN과 구분할 수 있는데, 일상 생활에서는 구분 없이 사용한다.
// - Virtual Local Area Network(VLAN)
// 논리적으로 나눈 스위치 네트워크를 말한다(물리적 배치와 상관없이 논리적으로 LAN을 구성할 수 있는 기술).
// 논리적으로 분리된 인터넷 프로토콜(IP) 하위 네트워크 이며, 이 하위 네트워크의 엔드포인트는 기능 또는 기타 공유 특성에 의해 연결됩니다.
// 논리적으로 네트워크를 구분하기 때문에 네트워크 구성이 유연하다. VLAN을 사용하면 네트워크의 보안성이 강화된다.
// - Simple Station Network(영어 해석 : 간이 망)
// SNMP(Simple Network Management Protocol)
// UDP/IP(사용자 데이터그램 프로토콜/인터넷 프로토콜)를 사용하여 이더넷 연결을 통해 네트워크 관리 작업을 수행하는 응용 계층 프로토콜
// IP 네트워크상의 장치로부터 정보를 수집 및 관리하며, 또한 정보를 수정하여 장치의 동작을 변경하는 데에 사용되는 인터넷 표준 프로토콜이다.
// SNMP를 지원하는 대표적인 장치에는 라우터, 스위치, 서버, 워크스테이션, 프린터, 모뎀 랙 등이 포함된다.
// - Mesh Network
// Mesh-Network.js 참고
// - 모뎀(MODEM, MOdulator and DEModulator)
// 정보 전달(주로 디지털 정보)을 위해 신호를 변조하여 송신하고 수신측에서 원래의 신호로 복구하기 위해 복조하는 장치를 말한다.
// 주로 컴퓨터 정보통신을 위한 주변기기로 많이 사용한다. 변조를 하는 이유는 전송선에 디지털 신호를 바로 보내면 신호 전달이 잘 되지 않기 때문이다.
// 데이터가 같은 비트로 연속되면 전송특성상 신호 전달에 문제가 발생하므로 전송선의 특성에 맞추어 변조한다.
// 모뎀은 아날로그/디지털 변환기의 일종으로 컴퓨터의 디지털 신호를 아날로그 신호로 바꾸어 전송하고, 아날로그 신호를 받아 디지털 신호로 읽어낸다.
// 좁은 의미에서는 개인용 컴퓨터와 전화선을 이어주는 주변기기이다.
// 모뎀은 인터넷 연결에 꼭 필요한 기기(일반적으로 공유기를 나타내는 말)
// 라우터는 모뎀과 연결하여 여러 기기에서 인터넷에 접속할 수 있도록 하는 기기
// - Modem Network(영어 번역 : 모뎀 네트워크)

// 88. 물리적 위협으로 인한 문제
// (1) 화재, 홍수 등 천재지변으로 인한 위협 - 물리적
// (2) 하드웨어 파손, 고장으로 인한 장애 - 물리적
// (3) 방화, 테러로 인한 하드웨어와 기록장치를 물리적으로 파괴하는 행위 - 물리적
// (X) 방화벽 설정의 잘못된 조작으로 인한 네트워크, 서버 보안 위협 - 기술적

// 89. 악성코드의 유형 중 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로 증식하는 것은?
// (1) Worm
// (X) Rogue Ware
// (X) Adware
// (X) Reflection Attack
// <해설>
// - Worm
// 악성코드(Malware)의 감염 방식 중 하나로, 웜은 여러 단말기에 분산되어 퍼져 그 단말기들이 연결된 네트워크 전체를 감염시킨다.
// 최근에는 악성코드 대부분이 네트워크 연결을 기본으로 트로이 목마의 위장 기능과 바이러스의 증식 기능을 탑재하기에 웜과 다른 악성코드를 칼같이 구분하지 않는다.
//  네트워크 전체를 공격한다는 특징 때문에 사이버 공격 도구로의 가치가 크게 주목받게 되면서
// 가장 위협적인 악성코드로써 전통적 악성코드 3종 분류 중 거의 유일하게 살아남은 분류로써 막대한 피해를 일으켜오고 있다.
// - Rogue Ware(Rogue Security Software, 가짜 백신 소프트웨어)
// 사용자가 컴퓨터에 바이러스가 있다고 잘못 믿게 하여 컴퓨터에 실제로 악성 프로그램을 설치하도록 하거나,
// 가짜 악성 프로그램 제거 도구에 대한 비용을 지불하도록 설득한다. 공포심을 통해 사용자를 조종하는 방식.
// - Adware
// 특정 소프트웨어를 실행할 때 또는 자동으로 활성화되는 광고 프로그램으로 이 자체는 악성코드로 보기는 힘들지만,
// 무분별한 광고 팝업을 뜨게 하는 등의 악용 위험성으로 악성코드로 분류되기도 함.
// - Reflection Attack(반사 공격)
// 송신자가 생성한 메시지를 가로채 공격자가 그 메시지를 다시 송신자에게 재전송하여 접근 권한을 얻는 형태의 공격 방법.
// - Reflection Attack 과정
// 사전에 암호 키를 공유한 송신자와 수신자는 상대방 식별을 위하여 각각 난수값을 생성하여 전송하고 이에 대한 암호값을 요청한 후
// 수신된 암호값을 복호화하여 그 결과 값이 자신이 송신하였던 난수값과 일치하는지 여부를 확인하여 상대방을 인증한다.
// 이때 공격자는 송신자가 보낸 난수값에 대한 암호값을 알기 위해 송신자가 보낸 난수값을 송신자에게 재전송하고,
// 이를 수신자의 난수값으로 인식한 송신자는 이에 대한 암호값을 공격자에게 전송하게 된다.
// 공격자는 이 암호값을 다시 송신자에게 전송함으로써 자신을 인증시키고, 그 결과 접근 권한을 획득.

// 90. 다음 설명에 해당하는 공격기법은?
// - 시스템 공격 기법 중 하나로 허용범위 이상의 ICMP 패킷을 전송하여 대상 시스템의 네트워크를 마비시킨다.
// (1) Ping of Death
// (X) Session Hijacking
// (X) Piggyback Attack
// (X) XSS
// <해설>
// - Ping of Death(죽음의 핑)
// 규정 크기 이상의 ICMP 패킷을 전송하여 시스템을 마비시키는 공격을 말한다.
// - Session Hijacking(세션 가로채기)
// 컴퓨터 시스템의 정보나 서비스에 무단으로 접근하기 위해 유효한 컴퓨터 세션(세션 키)을 이용하는 것.
// 일반적인 예로 두 컴퓨터 간에 활성화된 상태(즉, 로그인된 상태)에서 공격자가 피공격자의 로그인 정보를 활용하여 자신에게 필요한 행위를 하는 것을 뜻한다.
// - Piggyback Attack(피그백 공격)
// 공격자가 다른 사용자의 연결에서 계정을 사용하지 않는 비활성 기간(비활성 간격)을 이용하여 시스템에 엑세스(접근)한다.
// 이는 간선(회선 간) 공격이라고도 불린다.
// 쉽게 설명하자면, 시스템에 대한 합법적인 권한을 가진 사용자가 시스템에 접근할 때 활성화된 기간(직접 로그인 인증을 받아야 하는 상황)에는
// 접근 권한이 없는 공격자가 비활성화된 기간(합법적 사용자가 시스템에 접근 인증을 받은 상황)에 마치 사용자와 관련있는 사람인 듯이
// 태그를 붙여 몰래 뒤따라 들어가는 것이라고 할 수 있다.
// - XSS(크로스 사이트 스크립팅)
// 웹 사이트에 악성 스크립트를 주입하는 행위.
// 공격자가 상대방의 브라우저에 스크립트가 실행되도록 해서 사용자의 세션을 가로채거나, 웹 사이트를 변조하거나,
//  악의적 콘텐츠를 삽입하거나, 피싱 공격을 진행하는 것.
// <내용 정리>
// - 패킷(Packet)
// 정보 기술에서 패킷 방식의 컴퓨터 네트워크가 전달하는 데이터의 형식화된 블록이다.
// 패킷은 제어 정보와 사용자 데이터로 이루어지며, 이는 페이로드라고도 한다.
// - ICMP(Internet Control Message Protocol)
// 여러 정보를 전달하거나 컨트롤하는 용도로 사용되는 프로토콜입니다.
// 패킷 전송이 실패했을 때 에러가 났음을 알림과 동시에, 해결 가능한 힌트를 제공합니다.

// 91. 다음 설명에 해당하는 소프트웨어는?
// - 개발해야 할 애플리케이션의 일부분이 이미 내장된 클래스 라이브러리로 구현이 되어 있다.
// - 따라서, 그 기반이 되는 이미 존재하는 부분을 확장 및 이용하는 것으로 볼 수 있다.
// - JAVA 기반의 대표적인 소프트웨어로는 스프링(Spring)이 있다.
// (X) 전역 함수 라이브러리
// (2) 소프트웨어 개발 프레임워크
// (X) 컨테이너 아키텍처
// (X) 어휘 분석기
// <해설>
// - 프레임워크는 뼈대 골조를 의미하고, 특정 기능을 수행하기 위한 "클래스"나 "인터페이스"를 모아둔 집합체이다.
// <내용 정리>
// - 라이브러리
// 주로 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 비휘발성 자원의 모임이다.
// 여기에는 구성 데이터, 문서, 도움말 자료, 메시지 틀, 미리 작성된 코드, 서브루틴(함수), 클래스, 값, 자료형 사양을 포함할 수 있다.
// OS/360 및 이후 세대에서는 파티션 데이터 세트로 부른다.
// - 아키텍처(Architecture)
//
// - 워크로드(Workload)
// 고객 대면 애플리케이션이나 백엔드 프로세스 같이 비즈니스 가치를 창출하는 리소스 및 코드 모음을 말한다.
// 워크로드는 단일 리소스의 하위 집합으로 AWS 계정으로 구성되거나 여러 리소스에 걸친 리소스의 모음일 수도 있다.
// 워크로드는 애플리케이션을 지원하는 스토리지 객체이다. 애플리케이션별로 하나 이상의 워크로드 또는 인스턴스를 정의할 수 있다.
// 일부 애플리케이션의 경우 시스템에서 기본 볼륨 특성이 비슷한 볼륨을 포함하도록 워크로드를 구성한다.
// 이러한 볼륨 특성은 워크로드가 지원하는 애플리케이션 유형에 따라 최적화된다.
// 예를 들어, Microsoft SQL Server 애플리케이션을 지원하는 워크로드를 생성한 다음 해당 워크로드에 대한 볼륨을 생성하는 경우,
// 기본 볼륨 특성은 Microsoft SQL Server를 지원하도록 최적화되어 있다.
// - 컨테이너(Container)
// 소프트웨어 서비스를 실행하는 데 필요한 특정 버전의 프로그래밍 언어 런타임 및 라이브러리와 같은 종속 항목과 애플리케이션 코드를 함께 포함하는 경량 패키지.
// 운영체제 수준에서 CPU, 메모리, 스토리지, 네트워크 리소스를 쉽게 공유할 수 있게 해주며,
// 컨테이너가 실제로 실행되는 환경에서 애플리케이션을 추상화할 수 있는 논리 패키징 메커니즘을 제공한다.
// - 컨테이너의 이점
// 1) 책임 분리
// 예를 들어, 개발자는 애플리케이션의 로직과 종속 항목에 집중하고,
// IT 운영팀은 특정 소프트웨어 버전 및 구성과 같은 애플리케이션의 세부 요소 대신 배포 및 관리에 집중할 수 있다.
// 2) 워크로드 이동성
// 컨테이너는 Linux, Windows, Mac 등의 운영체제를 가리지 않고, 가상머신, 물리적 서버, 개발자 컴퓨터, 데이터 센터, 온프레미스 환경, 퍼블릭 클라우드 등
// 사실상 어느 환경에서나 구동되므로 개발 및 배포가 쉬워진다.
// 3) 애플리케이션 격리
// 컨테이너는 운영체제 수준에서 CPU, 메모리, 스토리지, 네트워크 리소스를 가상화하므로
// 개발자에게 다른 애플리케이션으로부터 논리적으로 격리된 OS환경을 제공한다.
// - 어휘 분석기
// 어휘 분석 단계에서 검출되는 의미 있는 조각을 어휘항목(lexeme)이라고 하며,
// 어휘 분석기는 소스 코드에서 이러한 어휘항목을 검출하여 토큰을 생성한다(어휘 분석에서 사용하는 용어를 정의함).

// 92. 소프트웨어 개발 방법론 중 애자일(Agile) 방법론의 특징
// (X) 각 단계의 결과가 완전히 확인된 후 다음 단계 진행
// (2) 소프트웨어 개발에 참여하는 구성원들 간의 의사소통 중시
// (3) 환경 변화에 대한 즉시 대응
// (4) 프로젝트 상황에 따른 주기적 조정
// <해설>
// - (1)은 폭포수 모형의 특징이다.

// 93. 대칭 암호 알고리즘과 비대칭 암호 알고리즘
// (1) 대칭 암호 알고리즘은 비교적 실행 속도가 빠르기 때문에 다양한 암호의 핵심 함수로 사용될 수 있다.
// (X) 대칭 암호 알고리즘은 비밀키 전달을 위한 키 교환이 필요하지 않아 암호화 및 복호화의 속도가 빠르다.
// (3) 비대칭 암호 알고리즘은 자신만이 보관하는 비밀키를 이용하여 인증, 전자서명 등에 적용이 가능하다.
// (4) 대표적인 대칭키 암호 알고리즘으로는 AES, IDEA 등이 있다.
// <해설>
// - 대칭 암호 알고리즘은 키 교환이 필요하기 때문에 키를 교환하는 중 키가 탈취될 수 있다는 문제가 있다.
// - 대칭 암호 알고리즘은 공개 암호화 방식에 비해 속도가 빠르다.
// <내용 정리>
// - Encryption.js 참고

// 94. 두 명의 개발자가 5개월에 걸쳐 10000 라인의 코드를 개발하였을 때, 월별(man-month) 생산성 측정을 위한 계산 방식으로 가장 적합한 것은?
// (X) 10000 / 2
// (2) 10000 / (5 * 2)
// (X) 10000 / 5
// (X) (2 * 10000) / 5
// <해설>
// - LOC : Line Of Code, 작성한 코드의 줄 수
// - 노력 측정 = 개발기간 * 투입인원
// - 개발비용 측정 = 개발기간 * 투입인원 * 단위비용
// - 개발기간 측정 = 예측된 LOC(라인) / (투입인원 * 1인당 월평균 LOC)
// - 생산성 측정 = 개발된 LOC / (투입인원 * 개발기간)
// <내용 정리>
// - man-month

// 95. 접근 통제 방법 중 조직 내에서 직무, 직책 등 개인의 역할에 따라 결정하여 부여하는 접근 정책은?
// (1) RBAC
// (X) DAC
// (X) MAC
// (X) QAC
// <해설>
// - RBAC(Role Based Access Control, 역할 기반 접근 통제) : 권한이 있는 사용자들만 접근할 수 있는 보안 방법
// - DAC(, 임의 접근 통제) : 사용자 또는 신분에 따라 접근을 제한하는 보안 방법
// - MAC(, 강제 접근 통제) : 미리 정해진 정책과 보안 등급에 따라 접근을 제한하는 보안 방법
// <내용 정리>
// - mandatory : 필수적인
// - discretionary : 재량의
// - RBAC(Role Based Access Control, 역할 기반 접근 통제)
// 컴퓨터 시스템 보안에서 권한이 있는 사용자들에게 시스템 접근을 통제하는 하나의 방법이다.
// RBAC는 정보에 대한 사용자(User)의 접근 권한을 각 사용자의 Identity나 이미 정해진 규칙에 의해 판단하지 않고,
// 사용자가 소속된 조직 내에서의 역학(Role)에 따라 결정한다.
// 즉, 정보에 대한 접근 권한이 역할에 따라 배정된다.
// 500명 이상의 직원이 있는 기업 다수가 사용하며, 강제 접근 제어(MAC)나 임의 접근 제어(DAC)를 구현할 수 있다.
// - MAC(Mandatory Access Control, 강제 접근 통제)
// 모든 정보에 security level을 각 user에게 security clearance(보안허가)를 할당하고 clearance를 가진 data에 대해서만 접근하도록 허용한다.
// - DAC(Discretionary Access Control, 임의 접근 통제)
// user의 identity에 따라 object에 대한 접근을 제어한다.

// 96. COCOMO(Constructive Cost Model) 모형의 특징
// (1) 프로젝트를 완성하는 데에 필요한 man-month로 산정 결과를 나타낼 수 있다.
// (2) 보헴(Boehm)이 제안한 것으로 원시코드 라인 수에 의한 비용 산정 기법이다.
// (3) 비교적 작은 규모의 프로젝트 기록을 통계 분석하여 얻은 결과를 반영한 모델이며 중소 규모 소프트웨어 프로젝트 추정에 적합하다.
// (X) 프로젝트 개발 유형에 따라 object, dynamic, function의 3가지 모드로 구분한다.
// <해설>
// - 개발 유형에 따라 조직형(Organic), 반분리형(Semi-Detached), 내장형(Embedded)으로 구분한다.
// <내용 정리>
// - man-month : 엄밀히는 men per month이고, 프로젝트에 투입되는 인원 대비 프로젝트 기간(월)을 나타낸다.
// - COCOMO
// 소프트웨어 개발의 공정 개발 기간의 견적 방법 중 하나이며, 1981년에 배리 W. 보임이 제창했다.
// 이 모델은 프로젝트에 영향을 줄 수있는 다양한 특성들을 변수로 회귀공식을 만들어 소프트웨어 개발 비용을 산정한다.
// 예를 들면, 개발기간, 투입공수가 프로젝트에 영향을 줄 수 있는 특성에 해당한다.
// 모델의 복잡도에 따라 Basic COCOMO, Intermediate COCOMO, Detailed COCOMO으로 세분화 할 수 있다.
// 개발 유형에 따라 조직형(Organic), 반분리형(Semi-Detached), 내장형(Embedded)으로 구분한다.

// 97. 각 사용자 인증의 유형에 대한 설명
// (1) 지식 : 주체는 '그가 알고 있는 것'을 보여주며 예시로는 패스워드, PIN 등이 있다.
// (2) 소유 : 주체는 '그가 가지고 있는 것'을 보여주며 예시로는 토큰, 스마트카드 등이 있다.
// (X) 존재 : 주체는 '그를 대체하는 것'을 보여주며 예시로는 패턴, QR 등이 있다.
// (4) 행위 : 주체는 '그가 하는 것'을 보여주며 예시로는 서명, 움직임, 음성 등이 있다.
// <해설>
// - 지식 : 본인이 알고 있는 것(패스워드, PIN 등)
// - 소유 : 본인이 가지고 있는 것(토큰, 스마트카드 등)
// - 존재 : 본인을 나타내는 것(홍채, 지문 등)
// - 행위 : 본인이 하는 것(서명, 움직임, 음성 등)

// 98. 시스템의 사용자가 로그인하여 명령을 내리는 과정에 대한 시스템의 동작 중 다음 설명에 해당하는 것은?
// - 자신의 신원(Identity)을 시스템에 증명하는 과정이다.
// - 아이디와 패스워드를 입력하는 과정이 가장 일반적인 예시라고 볼 수 있다.
// (X) Aging
// (X) Accounting
// (X) Authorization
// (4) Authentication
// <해설>
// - (3)은 권한 부여이다.
// <내용 정리>
// - AAA(Authentication Authorization Accounting)
// 보안의 한 방법으로, 지속적으로 독립적인 세가지 보안 기능(Authentication, Authorization, Accounting)을 설정 하는 구조적인 프레임이다.
// - Authentication(인증)
// 인증이란 식별 가능한 정보(이름, 이메일)를 이용하여 서비스에 등록 유저의 신원을 입증하는 과정이다.
// 즉, 자신의 서비스에 등록된 사용자에게만 서비스를 제공한다는 뜻.
// 역할 : 사용자 신원 확인, 로그인과 패스워드 응답, 도전과 응답, 메시징, 암호화
// - 인증(Authentication)의 방식
// 1) 세션-쿠키 방식 : 이번 글에는 해당 방식만 알아볼 것이다.
// 2) 토큰 (JASON Web Token, JWT) 방식
// 3) 다른 채널을 통해 인증(OAuth)
// - Authorization(인가)
// 인증만 가지고는 서비스를 운영하기에는 무리가 있다.
// 인증을 한 사용자에게 모든 서비스를 제공하게 된다면?
// 내가 작성한 글이 다른 사람에 의해서 수정되거나 삭제될 수 있다.
// 따라서 인증된 사용자가 접근하려는 자원에 대한 권한이 있는지 확인하는 절차가 필요할 것이다.
// 또한 인가는 항상 앞에 인증이라는 선행 프로세스가 필요하다(인증하지 않은 유저의 권한을 알 수 없기 때문에).
// 역할 : 멀티 프로토콜로 IP, IPX, ARA, Telnet, ssh를 지원
// - Accounting(회계)
// 인증받은 사용자가 무슨 동작을 하는지 기록하고 기록한 데이터를 AAA서버로 보내는 역할을 한다.

// 99. 다음에서 설명하는 IT 기술은?
// - 네트워크를 제어부, 데이터 전달부로 분리하여 네트워크 관리자가 보다 효율적으로 네트워크를 제어, 관리할 수 있는 기술
// - 기존의 라우터, 스위치 등과 같이 하드웨어에 의존하는 네트워크 체계에서 안정성, 속도, 보안 등을 소프트웨어로 제어, 관리하기 위해 개발됨
// - 네트워크 장비의 펌웨어 업그레이드를 통해 사용자의 직접적인 데이터 전송 경로 관리가 가능하고,
//   기존 네트워크에는 영향을 주지 않으면서 특정 서비스의 전송 경로 수정을 통해 인터넷상에서 발생하는 문제를 처리할 수 있음
// (1) SDN(Software Defined Networking)
// (X) NFS(Network File System)
// (X) Network Mapper
// (X) AOE Network
// <해설>
// - SDN(Software Defined Networking, 소프트웨어 정의 네트워킹)
// 네트워크 리소스를 최적화하고 변화하는 비즈니스 요구, 애플리케이션 및 트래픽에
// 신속하게 네트워크를 채택하는 데 도움이 되는 네트워크 가상화 및 컨테이너화에 대한 접근 방식이다.
// 개방형 API(오픈플로우)를 통해 네트워크의 트래픽 전달 동작을 소프트웨어 기반 컨트롤러에서 제어/관리하는 접근방식이다.
// 트래픽 경로를 지정하는 컨트롤 플레인과 트래픽 전송을 수행하는 데이터 플레인이 분리되어 있다.
// 따라서 네트워크의 세부 구성정보에 얽매이지 않고 요구사항에 따라 네트워크를 관리할 수 있다.
// - NFS(Network File System)
// 네트워크상에서 공유되는 파일 시스템.
// 다른 원격 호스트의 파일 시스템을 로컬 디스크에 접근하듯 간단하게 접근하여 자신의 디렉토리처럼 사용할 수 있다.
// - Network Mapper
// 네트워크 보안을 위한 유틸리티.
// 네트워크의 보안을 위해 물리적 연결, 어떤 서버와 운영체제가 작동 중인지 등을 조사하는 응용 프로그램
// - AOE Network(Activity On Edge Network)
// 어떤 프로젝트를 마치기까지 수행되는 작업의 각 단계(상태)를 그래프의 정점(Vertex)으로 표현하고,
// 작업 하나가 완료되어 다음 단계로 넘어가는 시간을 그래프의 간선(Edge)으로 나타낸 방향 그래프.

// 100. 프로젝트 일정 관리 시 사용하는 PERT 차트에 대한 설명
// (X) 각 작업들이 언제 시작하고 언제 종료되는지에 대한 일정을 막대 도표를 이용하여 표시한다.
// (X) 시간선(Time-line) 차트라고도 한다.
// (X) 수평 막대의 길이는 각 작업의 기간을 나타낸다.
// (4) 작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시한다.
// <해설>
// - 막대 도표가 아니라 네트워크 도표를 작성한다.
// - (1), (2), (3)은 GANTT 차트에 대한 설명이다.
// <내용 정리>
// - PERT(Program Evaluation and Review Technique) 차트
// 프로젝트에서 작업 일정을 수립하고 작업을 정리 및 계획하는 데 사용하는 툴이다.
// PERT는 프로그램 평가(Program Evaluation) 및 검토 기법(Review Technique)을 뜻합니다
// 프로젝트의 타임라인을 개별 작업으로 세분화하여 시각적으로 표현한 것으로, 간트 차트와 유사하지만 구조가 다르다.
// 프로젝트의 작업과 각 작업의 종속 관계를 시각적으로 표현한다.
// 프로젝트를 실제로 시작하기 전에 초기 일정과 예상 타임라인을 생성하여 프로젝트 이해관계자에게 공유하는 방식으로 사용할 수 있다.
// - PERT 차트와 같은 프로젝트 로드맵을 만들면 다음과 같은 프로젝트 계획 활동을 수행하는 데 도움이 된다.
// 1) 일정 및 타임라인에 대해 리더의 승인 받기
// 2) 이해관계자에게 프로젝트의 목표를 전달하기
// 3) 복잡한 프로젝트를 시각적으로 계획하기
// 4) 개별 작업을 완료하는 데 필요한 기간 예상하기
// - 네트워크 도표
// 제안된 사업의 시행으로 각종 행동이 연쇄적으로 어떤 환경 영향을 미치는지를 인과 관계를 중심으로 원인과 영향을 추적하여 일종의 네트워크로 표시하는 방식.
// 일반적으로 몇 개의 가능한 인과 관계를 네트워크로 표시하여, 제안된 사업의 각 행동이 야기할 각종 환경 영향을 사용자가 손쉽게 파악할 수 있게 한다.
// - GANTT(사람 이름) 차트
// 프로젝트 일정관리를 위한 바(bar)형태의 도구로서, 업무별로 일정의 시작과 끝을 그래픽으로 표시하여 전체 일정을 한눈에 볼 수 있다.
// 또한, 각 업무(activities) 사이의 관계를 보여줄 수도 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
