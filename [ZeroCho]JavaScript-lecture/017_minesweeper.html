<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>지뢰찾기 게임</title>
    <style>
      table {
        border-collapse: collapse;
      }
      td {
        border: 1px solid #bbb;
        text-align: center;
        line-height: 20px;
        width: 30px;
        height: 30px;
        background-color: #888;
      }
      td.opened {
        background-color: white;
      }
      td.flag {
        background-color: red;
      }
      td.question {
        background-color: orange;
      }
    </style>
  </head>

  <body>
    <table id="table">
      <tbody>
        <tr></tr>
      </tbody>
    </table>
    <div id="result"></div>
    <script>
      // 변수 선언부
      const $tbody = document.querySelector('#table tbody');
      const $result = document.querySelector('#result');
      const row = 10; // 줄
      const cell = 10; // 칸
      const mine = 10; // 지뢰
      const CODE = {
        NORMAL: -1, // 닫힌 칸(지뢰X)
        QUESTION: -2, // 물음표 칸(지뢰X)
        FLAG: -3, // 깃발 칸(지뢰X)
        QUESTION_MINE: -4, // 물음표 칸(지뢰O)
        FLAG_MINE: -5, // 깃발 칸(지뢰O)
        MINE: -6, // 닫힌 칸(지뢰O)
        OPENED: 0, // 0 이상이면 모두 열린칸
      };
      let data;

      // 함수 선언부
      // 지뢰 심는 함수(데이터 생성)
      function plantMine() {
        const candidate = Array(row * cell)
          .fill()
          .map((el, i) => i);
        const shuffle = [];
        while (candidate.length > row * cell - mine) {
          const randomIndex = Math.floor(Math.random() * candidate.length);
          shuffle.push(candidate.splice(randomIndex, 1)[0]);
        }
        const data = [];
        for (let i = 0; i < row; i++) {
          const rowData = [];
          data.push(rowData);
          for (let j = 0; j < cell; j++) {
            rowData.push(CODE.NORMAL);
          }
        }
        for (let k = 0; k < shuffle.length; k++) {
          const ver = Math.floor(shuffle[k] / cell);
          const hor = shuffle[k] % cell;
          data[ver][hor] = CODE.MINE;
        }
        return data;
      }
      // 클릭한 칸 주변에 지뢰 개수를 세는 함수
      function countMine(rowIndex, cellIndex) {
        const mines = [CODE.MINE, CODE.FLAG_MINE, CODE.QUESTION_MINE];
        let i = 0;
        mines.includes(data[rowIndex - 1]?.[cellIndex - 1]) && i++;
        mines.includes(data[rowIndex - 1]?.[cellIndex]) && i++;
        mines.includes(data[rowIndex - 1]?.[cellIndex + 1]) && i++;
        mines.includes(data[rowIndex][cellIndex - 1]) && i++;
        mines.includes(data[rowIndex][cellIndex + 1]) && i++;
        mines.includes(data[rowIndex + 1]?.[cellIndex - 1]) && i++;
        mines.includes(data[rowIndex + 1]?.[cellIndex]) && i++;
        mines.includes(data[rowIndex + 1]?.[cellIndex + 1]) && i++;
        return i;
      }
      // 우클릭 동작 ('contextmenu')
      function onRightClick(event) {
        event.preventDefault();
        const target = event.target;
        const rowIndex = target.parentNode.rowIndex - 1;
        const cellIndex = target.cellIndex;
        const cellData = data[rowIndex][cellIndex];
        if (cellData === CODE.MINE) {
          // 지뢰칸을 오른쪽 클릭하면 물음표지뢰칸으로 변경
          data[rowIndex][cellIndex] = CODE.QUESTION_MINE;
          target.textContent = '?';
          target.className = 'question';
        } else if (cellData === CODE.QUESTION_MINE) {
          // 물음표지뢰칸을 오른쪽 클릭하면 깃발지뢰칸으로 변경
          data[rowIndex][cellIndex] = CODE.FLAG_MINE;
          target.textContent = '!';
          target.className = 'flag';
        } else if (cellData === CODE.FLAG_MINE) {
          // 깃발지뢰칸을 오른쪽 클릭하면 지뢰칸으로 변경
          data[rowIndex][cellIndex] = CODE.MINE;
          target.textContent = 'X';
          target.className = '';
        }
        if (cellData === CODE.NORMAL) {
          // 닫힌칸을 오른쪽 클릭하면 물음표칸으로 변경
          data[rowIndex][cellIndex] = CODE.QUESTION;
          target.textContent = '?';
          target.className = 'question';
        } else if (cellData === CODE.QUESTION) {
          // 물음표칸을 오른쪽 클릭하면 깃발칸으로 변경
          data[rowIndex][cellIndex] = CODE.FLAG;
          target.textContent = '!';
          target.className = 'flag';
        } else if (cellData === CODE.FLAG) {
          // 깃발칸을 오른쪽 클릭하면 닫힌칸으로 변경
          data[rowIndex][cellIndex] = CODE.NORMAL;
          target.textContent = '';
          target.className = '';
        }
      }
      // 좌클릭 동작 ('onClick')
      function onLeftClick(event) {
        event.preventDefault();
        const target = event.target;
        const rowIndex = target.parentNode.rowIndex - 1;
        const cellIndex = target.cellIndex;
        const cellData = data[rowIndex][cellIndex];
        console.log(rowIndex, cellIndex, cellData);
        if (cellData === CODE.NORMAL) {
          // 닫힌칸 클릭하면
          const count = countMine(rowIndex, cellIndex);
          data[rowIndex][cellIndex] = count;
          target.textContent = count || ''; // count가 0이면 '', 그 이외에는 count표시
          target.className = 'opened';
        } else if (cellData === CODE.MINE) {
          // 지뢰칸 클릭하면
        }
        // 나머지는 아무 동작도 안함.
      }
      // 테이블 그리는 함수(데이터 기반으로 화면 그리기)
      function drawTable() {
        data = plantMine();
        data.forEach((row) => {
          const $tr = document.createElement('tr');
          row.forEach((cell) => {
            const $td = document.createElement('td');
            if (cell === CODE.MINE) {
              $td.textContent = 'X';
            }
            $tr.append($td);
          });
          $tbody.append($tr);
          $tbody.addEventListener('contextmenu', onRightClick);
          $tbody.addEventListener('click', onLeftClick);
        });
      }

      drawTable();

      // 자바스크립트의 핵심 : lexical 스코프, 실행 context, 이벤트 루프, promise, prototype
      // lexical 스코프 : 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 스코프가 결정됨.
      // 함수를 선언한 시점에 상위 스코프가 결정된다.

      // 호이스팅 : 변수를 선언하고 초기화했을 때 선언 부분이 최상단으로 끌어올려지는 현상.(초기화는 그대로 남아있음.)
      // 함수 표현식 : const say = function(){};

      // 함수 선언식 : function say() {}
      // 화살표 함수 : const say = () => {};

      // document.querySelector('#table tbody') : id가 'table'인 태그 안에 있는 tbody 태그를 선택.
      // document.querySelector 인수를 줄 때, 한 칸 띄우면 자식태그를 선택할 수 있다.

      // table 태그 내에 구획을 나누고 싶을 때는 thead, tbody, tfoot 태그를 사용할 수 있다.
      // 기능은 없지만 테이블 내에 구역을 나누는 용도로 사용한다.

      // 자바스크립트의 데이터는 최대한 적게 사용하고 html의 데이터를 사용하는 것도 좋다.

      // 프로그램을 처음 개발할 때는 간단하게 구현을 하고 점점 기능을 더해가는 것이 결과를 확인할 수도 있고, 개발 속도도 빠르다.
      // 데이터를 먼저 바꾸고나서 데이터를 바탕으로 화면을 수정하는 습관을 들이는 것이 좋다.

      // data[-1] -> undefined : 배열에 -1 인덱스를 주면 undefined 반환함.
      // slice, splice 메서드를 사용할 때는 마이너스 인덱스를 사용 가능하지만 마이너스 인덱스로 원소에 접근할 때는 undefined 반환.
      // data[-1][-1] : undefined[-1] 이므로 에러가 남
      // 앞 && 뒤 : 앞이 존재하면(true이면) 뒤를 실행한다.
      // 앞 || 뒤 : 앞이 존재하지 않으면(false이면) 뒤를 실행한다.
      // 앞 ?. 뒤 : 앞이 undefined나 null이면 평가를 멈추고 undefined를 반환한다. 그렇지 않으면 뒤까지 실행한다. (optional chaining)
      // 앞 ?? 뒤 : 앞이 undefined나 null이 아니면 앞, 그렇지 않으면 뒤를 실행한다. (nullish coalescing)
    </script>
  </body>
</html>
